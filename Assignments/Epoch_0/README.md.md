# HW: EPOCH 0
In this homework assignment, you will analyze a two initial binaries submitted from an intelligence feed. One pulled directly from an infected machine, and one that was downloaded based on an IOC in the binary. Both were tagged as being associated with malicious activity and have been found on our network! Your job is to analyze the binaries and determine if they are malicious and if so, dig into *what* about it is malicious.  To give a better idea of what it is I am looking for in this homework, the start section will review some material, and provide an example of a sample analysis 

## Notes
This assignment is going to be considerably harder. There are many more Easter eggs, flags, and rabbit holes! Be judicious with your time. If something doesn't work, think about why it might not be working. All malware was tested in the officially supported Lab environment and should be OK.
- I expect you to to provide thorough analysis of  at least the first two binaries (if they are malicious ) and at least the next stage binary.  
- There are more ( at least 4 other) malicious binaries hidden somewhere on the internet! The more you find and analyze, the more points you get!
- To reiterate, I only expect you to complete your analysis of two malicious binaries.  The more the better though. 





## Review: MITRE ATT&CK:
Required Reading: https://attack.mitre.org/resources/faq/ . Seriously, read this or I will smite you.  

In many situations, we are interested in the Tactics, Techniques and Procedures (TTPs) utilized by an attacker. As a refresher,  recall that 
- `Tactics` refer to tactical objectives of an adversary. The categories provided by MITRE ATT&CK are not comprehensive, but are usually a very good starting ground.
- `Techniques` refer to how the adversary achieves their desired tactical objective.
	- Note that for some techniques, we can have `sub-techniues` which provide more specific information about the technique used.
-  `Procedures` refer to specific *implementations* of techniques/sub techniques.
	-   I personally like to think about this as "playbooks"  used by a threat actor.
	-   I.e.  Do they use Evil Clippy to make Maldocs that drop Cobalt strike and finally deploy Ryuk ransomware? 
	-   `Procedures` are useful for comparing/contrasting how similar actors achieve similar tactical objectives using possible similar techniques!

To keep this concrete, lets apply this to the the malware we observed in class: `ClickMe.exe`.
We start by computing the SHA256 hash. There are many ways to compute this, but I will use powershell in case case.
```powershell
(Get-FileHash .\ClickMe.exe).Hash.ToLower()
aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27
```
Next, we check if the binary has already been uploaded to VirusTotal. DO NOT EVER UPLOAD WITHOUT CHECKING WITH YOUR BOSS/CLIENT!
In this case, it is already public: https://www.virustotal.com/gui/file/aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27
At the time of writing this, the following information is available: 
```
History
Creation Time	2022-02-03 23:09:18 UTC
First Submission	2022-02-03 18:09:37 UTC
Last Submission	2022-02-03 18:09:37 UTC
Last Analysis	2022-02-19 10:38:28 UTC
```
This is interesting, as it would appear that the Creation date is set to before the submission date. Does this mean VirusTotal somehow analyzed a binary before it was created? No, as it is possible tamper with the compilation date!

Scrolling down more, we see the target arch, number of sections and other basic properties of the executable:

```
Portable Executable Info Header
Target Machine	x64
Compilation Timestamp	2022-02-03 23:09:18 UTC
Entry Point	5664
Contained Sections	7
```
Feel free to click around and see what else is listed! Now onto the analysis.  As mentioned, `ClickMe.exe` is without a doubt a dropper malware. That is, it is a simple program that downloads and executes another executable hosted on a remote server. How did we determine this though? Lets analyze the binary using the playbook from Lecture 4:
We already have the SHA256 hash. Lets compute the Imphash using python's Pe-file

```python
import json
import pefile
pe = pefile.PE("ClickMe.exe")
pe.get_imphash()
'1d90d661956bbb69f1574b9663352b97'
```

Next, we can either use PE-bear, Ghidra, pefile or some other tool to list the imports. In this example, I will use `pefile` to create the import map in  the submission format. You should prune this down the imports that appears related to the type of malware you are looking at. In particular, since we have determined this malware to be a dropper, we will last functions associated with downloading and running an executable. 
```python

pe_import_dict = {}
# walk the Imports
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    dll_name = entry.dll.decode('utf-8')
    pe_import_dict[dll_name] = []
    for func in entry.imports:
        pe_import_dict[dll_name] += [func.name.decode('utf-8')]

		
print(json.dumps(pe_import_dict, indent=4, sort_keys=True))
```
Running the gives
```json
{
    "KERNEL32.dll": [
        "CloseHandle",
        "CreateProcessW",
        "DeleteCriticalSection",
        "EnterCriticalSection",
        "ExitProcess",
        "FreeConsole",
        "GetFileAttributesA",
        "GetLastError",
        "GetStartupInfoA",
        "GetTempPathW",
        "InitializeCriticalSection",
        "LeaveCriticalSection",
        "SetUnhandledExceptionFilter",
        "Sleep",
        "TlsGetValue",
        "VirtualProtect",
        "VirtualQuery",
        "__C_specific_handler"
    ],
    "SHLWAPI.dll": [
        "PathCombineW"
    ],
    "USER32.dll": [
        "MessageBoxW"
    ],
    "WININET.dll": [
        "DeleteUrlCacheEntryW"
    ],
    "msvcrt.dll": [
        "__getmainargs",
        "__initenv",
        "__iob_func",
        "__lconv_init",
        "__set_app_type",
        "__setusermatherr",
        "_acmdln",
        "_amsg_exit",
        "_cexit",
        "_commode",
        "_fmode",
        "_initterm",
        "_onexit",
        "abort",
        "calloc",
        "exit",
        "fprintf",
        "free",
        "fwrite",
        "malloc",
        "memcpy",
        "signal",
        "strlen",
        "strncmp",
        "vfprintf"
    ],
    "urlmon.dll": [
        "URLDownloadToFileW"
    ]
}
```
- A few suspicious Imports of note in format of a python dictionary where the key is the DLL name, and the value is a list of functions used from that DLL.  Please use this notation when submitting your answer. If your list isn't a valid python dict, I will deduct points. Note if you submit the entire import list, you will get no credit unless all of the imports are suspicious.   You may optionally justify your answer with commends 
```python
# based on the imports alone, this binary can download and execute content!
{
	"urlmon.dll":[
		# allows for downloading and saving remote content
		"URLDownloadToFileW"
	],
	"KERNEL32.dll":[
		# hides the running window. could be suspicious!
		"FreeConsole",
		# get information about files
		"GetFileAttributesA",
		# Allows for executing other binaries
		"CreateProcessW",
		# allows the exe to change memory protections! Could be sus
		"VirtualProtect"
	],
	"WININET.dll":[
		# ensures we don't cache downloaded content and forces a download
		"DeleteUrlCacheEntryW"
	],
	"USER32.dll":[
		# why is a console application popping message boxes?
		"MessageBoxW"
	]
}
``` 
Next, we can look for suspicious strings.
```python
[
	# ANSI string with null terminator. b"" is a byte string (utf-8 usually)
	
	# Env Keying! Won't run without this file. What does it mean!?
	b"C:\malware\ch0nky.txt\0",
	# u"" is a unicode string which we will use for wide character strings 
	# \0 will add 2 null bytes for u"" and 1 for b""  bytestrings
	
	# Bruh, Rickroll!
	"For a good time: https://www.youtube.com/watch?v=dQw4w9WgXcQ\0".encode("utf-16"), 
	
	# Rude
	"GO AWAY!\0".encode("utf-16"),
	# IOCs:  evilch0nk.cf, http://evilch0nk.cf/evil.exe evil.exe
	"http://evilch0nk.cf/evil.exe\0".encode("utf-16"),
	# I do not trust you. You are definietly going to be malware
	"TrustMeNotMalware.exe\0".encode("utf-16"),
	...
	
]
```

Lets do a quick pivot: are there any Associated IP addresses to ch0nky.cf? 
Doesn't look like it...Maybe this is a testing domain or an error? Perhaps we should check this for other domains we encounter in this homework ... `;-)`
![[evil_ch0nk.png]] 
However, based on the assembly, we can confirm that it is downloading a binary `evil.exe` from `http://evilch0nk.cf/evil.exe` and saving it as `$temp\TrustMeNotMalware.exe`
![[download_evil.exe.png]]
After, we see a call to `CreateProcessesW` after which the processes terminates. After popping a message box asking the user to infect their computer, the binary is executed. 
![[create_proc_w.png]]

Without the second stage binary, we we are unable to piece together the full picture of the adversary's objective, but we can determine that they are attempting to execute more code!  

We could even speculate that based on the PE's name and Icon, `ClickMe.exe` is a part of a phishing campaign. However, without more IOCs, we cannot conclude this.   

Now lets use the Language of MITRE ATT&CK to state precisely what we do know about the binary, and  the unknown thread actor. 

While we can't say much with just this binary, we can say that the goal of this particular binary is to download and execute more code! This corresponds to `TA0002:Execution`  https://attack.mitre.org/tactics/TA0002/ . The creator of `ClickMe.exe`'s objective was likely  to download and execute more (most likely) malicious code!  The associated technique in this case is `Native API:T1106` https://attack.mitre.org/techniques/T1106/ . Note that Native here just means using functions/interfaces provided to programmers by the OS. For Windows, this includes the Windows API and the Native API. Since the new binary is executed using `CreateProcessesW` , and this is a function provided to us by the Windows API, we conclude the  the Binary Achieves `Execution` via  a `Native API` function.  


`<rant>`:  I would argue the above situation is a clear example of what I would consider to be a limitation of the MITRE ATT&CK Matrix:  the sub techniques can be a bit sparse.  I would argue that it would be important to distinguish an adversary who called `CreateProcessW` from one who used the Windows *native* API equivalent `NtCreateProcesses` and one who parses the Syscall number and directly creates a new processes via a Syscall.  `</rant>`

Now that we understand what the binary does, lets think about how the binary was executed in the first place. We can say with medium to high confidence, that the way the adversary envisioned the binary getting executed likely involved user interaction!  Said differently, the tactical objective of `ClickMe.exe` is to download and execute more code, it needs to first get executed itself! How?  likely via `User Execution:T1204`.  We can be even more specific in this case and use the sub technique  `User Execution: Malicious File:T1204.002` https://attack.mitre.org/techniques/T1204 . We make this (educated guess) based on the name `ClickMe`, and the meme Icon.

# Directions 

In this assignment, you will analyze two initial binaries. These binaries may help you identify other binaries!
For each binary, you will do the following: 
## Static Analysis and Triage:
Find/answer the following
- SHA256 hash of the binary. Please  encode the digest bytes as lowercase hex. 
- Import hash  of the binary. Again, please  encode the digest bytes as lowercase hex. 
- The architecture of the binary. Is it 32bit or 64bit (for this, submit either `32` or `64`)
- When was it compiled? Use Unix epoch time. Same format as python `time.time()` 
- Is this  malware? `True` or `False` 
- If so,what kind of malware is it?  Please see appendix for options for this homework.
- Justify your answer or submit `N/A`
- python list of suspicious strings. If none, submit `[]`
- python list of suspicious imports  If none, write `[]`
- please provide a python list of IOC pairs If none, write `[]`. Here a pair is a `dict` object that contains a the type of IOC, the value, and a justification. For example: 
```python
[
	{"type": "URL", "Value": "http://evilch0nk.cf/evil.exe", "Comments": "Url where the second stage payload was likely stored"}
	, 
	{"type":"Domain", "Value":"evil.ch0nk.cf", "Comments": "Domain associated with server hosting second stage payload"}, 
	{"type": "sha256", "Value": "2edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27", "Comments": "sha256 hash of ClickMe.exe. Known bad."}
	...
]
```
Note that some values might fall into multiple categories such as `"C:\malware\ch0nky.txt`.  Submit a separate IOC for each category it satisfies.  
## MITRE ATT&CK Mapping
For each binary that you determine to be malicious, identify all Tactics and Techniques associated to the Binary.  You submission should be a python dictionary/JSON compatible . For example, if the binary as `ClickMe.exe`, I would expect your answer to look like this:
```python 
# Execution->[Native API, User Execution]
{
	"TA0002": {
		"Techniques":["T1106", "T1204"],
		"Comments": "Optional justification"
	}
}
```

For this Assignment, you are only responsible For the following Tactics.
- [Execution](https://attack.mitre.org/tactics/TA0002)
- [Persistence](https://attack.mitre.org/tactics/TA0003)
- [Discovery](https://attack.mitre.org/tactics/TA0007)
- [Defense Evasion](https://attack.mitre.org/tactics/TA0005/)
- [Command and Control](https://attack.mitre.org/tactics/TA0011)
- [Impact](https://attack.mitre.org/tactics/TA0040)
You are not responsible for Sub-techniques for this homework but will be in subsequent assignments!  You should read through the Windows ATT&CK Matrix and understand what each Tactic is listed above. For each tactic, see if you can identify the technique used by the binary! 

# Threat Actor
Answer the following:
- Who is this threat actor targeting?  How did you come to this conclusion 


## Extras
### Observe Actor behavior 
### Extra IOCs
- Try and use the IOCs you found in the previous sections to find more IOCs not found in the current binaries!
- Flags...there may be some flags :-)
- Challenge: Can you find the secret C2(s)? 
- For each C2, is it custom, proprietary, or an opensource tool?

### Operator interaction
There seems to be someone on the other end of some of the malware-- perhaps even an interactive session!  Map the commands/actions performed by the operator to  MITRE ATT&CK



### Warning 
** WARNING: The final payload uses flashing effects that may potentially trigger seizures for people with photosensitive epilepsy. There will be a MessageBox before it is executed that asks if you would like to detonate the payload.  The warnining box  is not part of the assignment and should be ignored for the purposes of analysis.  If you are photo sensitive and would still like to analyze the content, feel free to message me and I will create a build that doesn't flash. **
The final Payload may also require a reboot :-). It does no permanent damage. It is also very loud. 



# Rules of engagement
This assignment has at least one live C2s associated with Ch0nky bear. In the real world, if you encounter a C2, you might be tempted to try and hack into it and see whats there. I would advise against this course of action. 
- For one, if you try and hack the C2 and you are detected, they might burn their infrastructure, change their TTPs, and now you are back at square 1. 
- Two: it is likely in violation of the CFAA which will likely result in jail time. Unless you have special protections by your government, you are likely playing with fire. Don't do this. 
	- If you are wrong, and it is not a C2, and you accidentally break something, you are seriously in violation of the CFAA. Remember the cardinal rule of infosec: Do not piss off anybody that has more time and money than you do!
		- Many C2s use hacked infra.  This is a serious risk you run.
- Three: There are usually better ways to figure out the inner workings of the C2!

- In this class, if you try and hack a C2 without explicit consent, ** you will automatically fail the class** . Infosec requires ethics. If you display a lack of ethics, you are out of the class. No questions asked, no appeals. Goodbye, see you never. 
- If you would like to try your luck at hacking the C2,  this will be an option for subsequent assignments-- but NOT this one! Patience....
- If you intentionally knock over the C2, you will fail the class. 
- You are welcome to do basic enumeration (i.e. **light** port scanning, clicking around...etc)
	-   `nmap -T1`  is fine, but you won't find much here ;). 
- You may not bruteforce anything on  the server. This includes passwords, SSH keys, file paths ...etc. 

# Warning
One payload for this assignment will consume system resources and might require a reboot of the machine. Don't run the code on your real environment. 

# Hints
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
- One of the payloads is designed to be difficult to graph with ghidra. Perhaps you should look at other functions instead of `main`!
- If you have antivirus turned on, some payloads might not work. 
	-	make sure to disable real time protection
-	Netcat is your friend. 

# Appendix
 If you don't recognize something, google it/ ask **publicly** on Piazza/Discord :-)
 
 ## Malware Types
Valid malware *types* for this assignment:
 ```python
["ransomware", "scareware/trolling", "dropper", "loader", "worm", "stealer", "spyware", "root_kit","reverse_shell", "remote_access_trojan", "crypto_miner","wiper", "adware", "generic/hackingtool"]
```

## IOC Types
IOC types for this homework.
```python
["sha256", "imphash", "domain", "URL", "IP", "file_name", "scheduled_task", "run_key", "DLL", "DLL_exported_function", "PE_string", "mutex", "named_pipe"]
```    


# submission Guidelines 

The Submission for the JSON will be autograded. You need to submit a single  JSON object that contains your solution. To that end, you must submit a JSON object with 3  keys. Each key corresponds to a list of solutions for a particular section. 

The base template for your submission is provided below

```json
{

"binaries": [ ],

"Flags": [ ],

"C2s": [ ]

}
```

## Binaries
For each binary, you have identified and analyze, please include an entry into binaries section of the json object as descrbied above. For Example, for `ClickMe.exe` the entry would be as follows:

```json
{
    "binary_name": "ClickMe.exe",
    "sha256": "aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27",
    "imphash": "1d90d661956bbb69f1574b9663352b97",
    "arch": 64,
    "compile_time": 1643929758,
    "strings": [
        "http://evilch0nk.cf/evil.exe",
        "C:\\malware\\ch0nky.txt"
    ],
    "imports": {
        "urlmon.dll": [
            "URLDownloadToFileW"
        ],
        "KERNEL32.dll": [
            "FreeConsole",
            "GetFileAttributesA",
            "CreateProcessW",
            "VirtualProtect"
        ],
        "WININET.dll": [
            "DeleteUrlCacheEntryW"
        ],
        "USER32.dll": [
            "MessageBoxW"
        ]
    },
    "iocs": [
        {
            "type": "sha256",
            "Value": "aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27",
            "Comments": "sha256 Hash of the  ClickMe.exe"
        },
        {
            "type": "imphash",
            "Value": "1d90d661956bbb69f1574b9663352b97",
            "Comments": "Imphash of ClickMe.exe"
        },
        {
            "type": "file_name",
            "Value": "ClickMe.exe",
            "Comments": "Malicious EXE filename"
        },
        {
            "type": "URL",
            "Value": "http://evilch0nk.cf/evil.exe",
            "Comments": "Evil url"
        },
        {
            "type": "domain",
            "Value": "evilch0nk.cf",
            "Comments": "evil domain"
        },
        {
            "type": "file_name",
            "Value": "TrustMeNotMalware.exe",
            "Comments": "dropped file"
        }
    ],
    "mitre_att&ck": {
        "TA0002": {
            "Techniques": [
                "T1106"
            ],
            "TechniquesNames": [
                "Native API"
            ],
            "Comments": "<Native API:Call to CreateProcess>"
        },
        "TA0011": {
            "Techniques": [
                "T1071"
            ],
            "TechniquesNames": [
                "Application Layer Protocol"
            ],
            "Comments": "<Application Layer Protocol:Downloads via HTTP>"
        },
        "TA0005": {
            "Techniques": [
                "T1564"
            ],
            "TechniquesNames": [
                "Hide Artifacts"
            ],
            "Comments": "<Hide Artifacts:FreeConsole>"
        }
    },
    "verdict": true,
    "classification": "dropper",
    "verdict_justification": "downloads and executes malicious file"
}

```

## Flags
Submit a list of flags in the flags section. note this is only for flags that you understand how to retrieve. 
For Example: 
```json
["FLAG{Foo}", "FLAG{BAR}"]
```
## C2s

This is a list of **domains** and **ip** addreeses
for example:
```json
["google.com", "8.8.8.8"]
```


Complete example:

```json
{

"binaries": [ {
    "binary_name": "ClickMe.exe",
    "sha256": "aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27",
    "imphash": "1d90d661956bbb69f1574b9663352b97",
    "arch": 64,
    "compile_time": 1643929758,
    "strings": [
        "http://evilch0nk.cf/evil.exe",
        "C:\\malware\\ch0nky.txt"
    ],
    "imports": {
        "urlmon.dll": [
            "URLDownloadToFileW"
        ],
        "KERNEL32.dll": [
            "FreeConsole",
            "GetFileAttributesA",
            "CreateProcessW",
            "VirtualProtect"
        ],
        "WININET.dll": [
            "DeleteUrlCacheEntryW"
        ],
        "USER32.dll": [
            "MessageBoxW"
        ]
    },
    "iocs": [
        {
            "type": "sha256",
            "Value": "aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27",
            "Comments": "sha256 Hash of the  ClickMe.exe"
        },
        {
            "type": "imphash",
            "Value": "1d90d661956bbb69f1574b9663352b97",
            "Comments": "Imphash of ClickMe.exe"
        },
        {
            "type": "file_name",
            "Value": "ClickMe.exe",
            "Comments": "Malicious EXE filename"
        },
        {
            "type": "URL",
            "Value": "http://evilch0nk.cf/evil.exe",
            "Comments": "Evil url"
        },
        {
            "type": "domain",
            "Value": "evilch0nk.cf",
            "Comments": "evil domain"
        },
        {
            "type": "file_name",
            "Value": "TrustMeNotMalware.exe",
            "Comments": "dropped file"
        }
    ],
    "mitre_att&ck": {
        "TA0002": {
            "Techniques": [
                "T1106"
            ],
            "TechniquesNames": [
                "Native API"
            ],
            "Comments": "<Native API:Call to CreateProcess>"
        },
        "TA0011": {
            "Techniques": [
                "T1071"
            ],
            "TechniquesNames": [
                "Application Layer Protocol"
            ],
            "Comments": "<Application Layer Protocol:Downloads via HTTP>"
        },
        "TA0005": {
            "Techniques": [
                "T1564"
            ],
            "TechniquesNames": [
                "Hide Artifacts"
            ],
            "Comments": "<Hide Artifacts:FreeConsole>"
        }
    },
    "verdict": true,
    "classification": "dropper",
    "verdict_justification": "downloads and executes malicious file"
}
],

"Flags": ["FLAG{Foo}", "FLAG{BAR}"],

"C2s": ["google.com", "8.8.8.8"]

}
```

# Common Mistakes
- submiting a python dict instead of a JSON object. Please use `json.dumps(my_dict)` to get a proper json object
- Please make sure your quotes are `"` and not `'` or some other variant. 
