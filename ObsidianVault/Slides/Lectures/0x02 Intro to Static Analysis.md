---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x02: 
Introduction to IOCs and Static Analysis


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Agenda for Today

:::

<!-- element style="font-size: 24px"-->
- Baby's first (compiled!) Malware
- This class will build on the python malware from last lecture
- Keep the following question in the back of your mind: 
- Pre-Req: binary, hex and base64 encoding, C-strings

What is needed to control a computer?


---
<!--slide template="[[Title Slide]]"-->
- Today we will talk about concepts that have yet to be rigorously defined 
- This lecture is all about building intuition for triageing malware

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### More Definitions
:::
<!-- element style="font-size: 24px"-->
- Indicators of Compromise (IOCs):
 sets of forensic data found when malicious activity occurs. (IPs / domains of a C2 server, hash values of malware, email accounts of phishing email senders..etc)
- Hash value: the  fingerprint of a some data
- IP address:  the address of a computer on a network.
- Domain Name: n entry for a A/AAAA record used by a DNS servers to map human friendly names (like google.com) to computer friendly IP addresses (8.8.8.8).


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Refresher: Cryptographic Hash

:::

<!-- element style="font-size: 24px"-->
- Imagine an oracle that has an  infinite memory
- You present them an input 
- If the oracle has not seen the input before, it randomly flips 256 fair coins and returns the binary sequence
- If it has seen the input before, it returns the stored output 
- Cryptographic hash functions, if they are “secure”, should be indistinguishable from such an oracle


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Cryptographic Hash Functions

:::

<!-- element style="font-size: 24px"-->
- Non-example: CRC32/DBJ
- Sha256 → Safe
- SHA1 → unsafe
- MD5 → Very unsafe. Still used for some reason
- BLAKE Family: :fire:
- SHA3: probably fine, less common for TH
- Cryptographic Hash functions will provide a probabilistically unique fingerprint for files. I.e., the probability of finding two inputs with the same hash should be **very** low 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Remark about Cryptographic hash functions
:::

::: left
<!-- element style="font-size: 24px"-->
- They take binary sequences of arbitrary length, and produce a fixed size digest
- The probability of finding collisions is 
exponentially low
- But there are an infinite number of collisions. 
- How is this possible?

:::

::: right
![[0x03_slide_7_image.png|600]]


:::


---
<!-- slide template="[[Base Slide]]"-->
::: title
#### Key Properties 
:::
<!-- element style="font-size: 24px"-->
- arbitrary inputs produce fixed length bit strings where each bit $$B_i \sim_{\text{i.i.d}} B(p=1/2)$$
- changing even a single bit gives you a totally random output 
- the function is public, and is possible to brute force for low entropy inputs!
- i.e. try Googleing the following hex output 
<small>`5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8` </small>
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Threat Analysis Pyramid of Pain

:::

::: left
<!-- element style="font-size: 24px"-->
- IOCs are used to track and identify threats 
- IOCs should be simple values that can be easily shared with others

Taking into account the context of a collection of  IOCs can help identify TTPs

:::

::: right
![[0x03_slide_8_image.png|500]]


:::


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### From IOCs to TTPs
:::


<!-- element style="font-size:24px"-->
#### Hash -> Tools
- What malware family does this hash belong to? 
	- What is it used to do?
- How are all these hashes similar? 
	-  Are they different versions of the same malware? Different tools?

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### From IOCs to TTPs
:::


<!-- element style="font-size: 24px"-->
####  IP/Domain -> Network Artifact
- How does the malware communicate with the C2? 
- Can I look at common patterns in the network traffic and block that behavior?
- What domains are being used? Is this known bad/reused? What registrar was used?
- Is the IP hacked infra? 
- What ASN does it belong to ?

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### From IOCs to TTPs
:::


<!-- element style="font-size: 24px"-->
#### IOC -> TTPs: 
- Is there a pattern in the way this group conducts operations? 
- Do they drop multiple malware families? 
- Do they look for specific data? 
- How do they get the malware on the system?
- Who are they targeting?
- How do I block this activity?

This is in general very difficult to do!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Easy…until it isn’t!

:::

<!-- element style="font-size: 24px"-->
- Depending on the actor, the Pyramid of Pain might just be pain. 
- Hashes are easy, 
unless they use polymorphic code
- IPs are easy, 
unless they use thousands of addresses all of which are compromised infrastructure
. Hint: what happens when someone takes over a hosting proider or a cloud account?
- Domains are easy, unless they use a domain generating algorithm (DGA) or quickly change them
- Or…you know what if someone compromises a bunch of legitimate sites and use them to carry out  cyber operation?
- What about a slack C2? **P A I N**

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Different companies see different IOCs
:::

::: left
<!-- element style="font-size: 24px"-->
- Antivirus/EDR companies ( McAfee/Crowdstrike) see the malware that attackers use.
- Mail providers (Gmail, Yahoo) see the phishing emails.
- Domain registrars (Namecheap / GoDaddy) see Command and Control registration.
- Nobody sees everything. 
Analysis is hard.
- You’re going to have to work as a team.  


:::

::: right
![[0x03_slide_12_image.jpg|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Importance of Relationships	

:::

<!-- element style="font-size: 24px"-->
- Go out into the world and make friends. 
- Nobody has the complete picture
- collaborate, communicate, and deconflict
- How can you check equities if you don’t ever reach out


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Remark on Infosec Savants
:::

::: left
<!-- element style="font-size: 24px"-->
- There are plenty of brilliant people working in infosec
- No such thing as someone who has all the answers
- In fact, someone who claims they do is likely wrong, lying, or trying to sell you something. 
- There is no Infosec Dr. House. It’s probably just someone with a bit too much self confidence, and they probably are not fun to work with. 
- <b> Cybersecurity is a team sport. </b> 


:::

::: right
![[0x03_slide_14_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Reminder!
Different entities also use different jargon!
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Class Progression (Defenders)

:::

<!-- element style="font-size: 24px"-->
- Analysing Malware
  -  (pulling out the IOCs in the malware)
- Example Assignment: Find all C2 domains, interesting files, and implant configuration, and imports!
- Writing up a Technical Report on the Malware
  -  (explaining the IOCs and how the malware works)
- Example Assignment: What is the malware trying to accomplish?
- Creating Threat Hunting Rules to find more malware
- Example assignment: finding all code associated to APT Chonky bear in a collection of binaries

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Class Progression (Defenders)

:::

<!-- element style="font-size: 24px"-->
- Analysing First stage loaders: 
Analysing Malware
  -  (pulling out the IOCs in the malware)
- Writing up a Technical Report on the Malware
  -  (explaining the IOCs and how the malware works)
- Creating Threat Hunting Rules to find more malware

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Malware Analysis 101

:::

<!-- element style="font-size: 24px"-->
- Static Analysis: Analyzing the code to determine functionality/capabilities without executing/emulating code.
- Dynamic Analysis: Executing, or emulating all or portions of code to determine behavior by 
examining
 runtime artifacts. 
- Today, we will focus on basic static analysis!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What are we actually interested in?

:::

<!-- element style="font-size: 20px"-->
![[CommonMalwareQuestions]]


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### How do we begin to answer these questions?
:::

::: left
<!-- element style="font-size: 24px"-->
- Tear the the malware apart and see what it does 

:::

::: right
![[0x03_slide_20_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Purpose of Static Analysis
:::

::: left
<!-- element style="font-size: 24px"-->
- Identify potential IOCs 
	- (usually easy) 
- Determine functionality 
	- (Usually hard)
- Keep optometrists in 
business
- Highly recommended: use dark mode

:::

::: right
![[0x03_slide_21_image.png|600]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Common IOCs 

:::

<!-- element style="font-size: 24px"-->
- Domains / URLs / IPs 
- Mutex and Pipe names.
- RPC commands, Debug information..etc
- Files/folders names 
- Executable hash value (md5 / sha256 / blake2b/ importhash)
- YARA Rule Match 
(we have a whole lecture on this)
- Resources/ section data 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Static Analysis

:::

<!-- element style="font-size: 24px"-->
- Brief: Analyzing code without running it. 
- Longer: Static analysis involves looking at data stored in an executable file or script to determine its functionality and to extract IOCs if it is deemed malicious.
- Let's briefly introduce executables
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Executable File Formats

:::

<!-- element style="font-size: 24px"-->
- Bundles of machine code and associated data needed to run a program
- Usually requires an OS to load the executable
- Code is organized according to a convention that the programmer and the kernel agree on. 
	- It is just a convention though!  More accurately, an exe needs a *loader* to *load* it
	- The convention is between the *executable* and the *loader*


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format Basic Definitions and Concepts 

:::

<!-- element style="font-size: 24px"-->
- Portable Executable (PE) is an executable file format used by Windows NT
- It contains information about code to execute, and how it should be executed
- In this discussion, we will use an open source tool PE-Bear to look at the structure of a PE file.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format 

:::

<!-- element style="font-size: 24px"-->
- PE file format is used for both userland and kernel mode executables
	- Userland: file.exe, file.dll, file.obj 
	- Kernel mode: driver.sys, ntoskrnl.exe 
- PE is  based on the Common Object File Format (COFF).
- PE format is not architecture specific (hence “portable”)
	- Note this means the format can be used across multiple different architectures. The  target architecture is still specified inside of the PE though
- Data is grouped together in blocks called 
sections
, identified by 
headers


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE: Libraries

:::

<!-- element style="font-size: 24px"-->
- Windows shared libraries are called Dynamically Linked Libraries
- They are PE files with a special bit set
- They can export functions from their code (Technically, nothing is stopping a .exe from exporting code)
- Other PEs can load these libraries and access the exported code
- This allows for modular programs
-  We will talk more about this next lecture when we review linking. 



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE

:::

<!-- element style="font-size: 24px"-->
- PEs are composed of sections and headers
- Sections are data/code
- Headers contain information about how to load the PE, and where the data is, and how to process it 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Where to start? PE/DLLs Files

:::

<!-- element style="font-size: 24px"-->
- Hash The binary. Search for that hash on VirusTotal.
- Strings: Look at the C strings found in the file (Null/double null terminated)
- Imports: Look at the libraries 
imported
 by the PE. If you see LoadLibrary, search for where it is called
- Exports: Does it export functions?
- Resources: What 
resources
 are stored in the executable?
- Entrypoint → main 
assembly
 view
- Decompiled View 
- X-refs


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Recommended Hash functions:

:::

<!-- element style="font-size: 24px"-->
- Defn: Hash 
Collision
: H(x) = H(y) for x != y
- MD5: A very fast, but BUSTED hash function. It is easy to 
generate collisions
 and you should not rely on this on its own. 
- SHA256: More reliable, and as of now has no collisions. 
- ImpHash: md5 hash of the import table. Why did Fireeye choose md5 for the 
algorithm
 if it is “busted”? The answer is it is fast, common, and more difficult to exploit in statically declared imports. Though technically still 
possible


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Hashing
:::

::: left
<!-- element style="font-size: 24px"-->
- sha256sum,  md5sum, python

:::

::: right
![[0x03_slide_26_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Imphash

:::

<!-- element style="font-size: 24px"-->
- In [3]: import pefile
- In [4]: pe = pefile.PE("mal.exe")
- In [5]: pe.get_imphash()
- Out[5]: 'bfc87dbd7dcec45f2680c2ddf9f8e98c'

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Analysis Playbook
:::

![[0x03_slide_28_image.png|700]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Your First Malware!
:::

<!-- element style="font-size: 24px"-->
- ClickMe.exe 
-  hash: <small>`aa0df10302edf9264d1996a8a0a21a65e9e632e527e1b7ce2ce82c6bda81db27`</small>



![[0x03_slide_29_image.png|900]]



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- Most PEs will "link" against Libraries to access functionality at run time
- For now, treat this like you would python imports
- Tools: Ghidra, PE-Bear, objdump, pefile
:::

::: right
![[0x03_slide_30_image.png|800]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Imports 
:::

::: left
<!-- element style="font-size: 24px"-->
Example: looking at imports in PE-bear
- Recall: DLL has library code referenced by a PE
- The specific function is listed in the second table
- Common notation:
	- `dll_name$FuncName` 
	- `dll_name!FuncName` (WinDBG symbol)
:::

::: right
![[0x03_slide_31_image.png|900]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- For quick analysis/triage, PE-Bear  is fantastic! 
- For longer looks, I always use an SRE  such as Ghidra
- usually becaues you can X-ref the imports!

:::

::: right
![[0x03_slide_32_image.png|900]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Imports: Why do we care?
:::

::: left
<!-- element style="font-size: 24px"-->
- Looking at imports can provide us valuable information about the capabilities of the code!
- Can it Allocate memory? Can it interact with the network? Can it spawn new processes? …etc
- Windows processes are not sandboxed by default and can load additional capabilities
 and resources  dynamically! 


:::

::: right
![[0x03_slide_33_image.png|900]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Some Interesting Imports 

:::

<!-- element style="font-size: 24px"-->
- urlmon.dll$URLDownloadToFileW
- WININET.dll$DeleteUrlCacheEntryW
- SHLWAPI.dll$PathCombineW
- USER32.dll$MessageBoxW
- KERNEL32.dll$CreateProcessW
- KERNEL32.dll$FreeConsole
- KERNEL32.dll$GetTempPathW


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Strings 

:::

<!-- element style="font-size: 24px"-->
- Tools: strings.exe, Pestudio, Ghidra
- I prefer Ghidra as we can specify the types of strings we will search for. 
- To search for strings, click “search” → “for strings”   
- Sometimes, you will find PDB paths, C2 urls, commands, messages…etc
- However, malware authors can easily encrypt strings. 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Strings
:::
::: left
<!-- element style="font-size: 24px"-->
- Ghidra is again best for longer looks. 
- X-REF strings 
:::

::: right
![[0x03_slide_36_image.png|800]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Sections 
:::

::: left
<!-- element style="font-size: 24px"-->
- We will spend more time on the PE file format
- For now, keep in mind that data is stored in 
sections
- Typical sections you will see are
- .text: executable code
- .data: global variables/data
- .rdata: read only global variables/data
- .rsrc: PE resources (i.e., 
embedded
 data, icons…etc)


:::

::: right
![[0x03_slide_37_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Resources
:::

::: left
<!-- element style="font-size: 24px"-->
- Special section used to store data in a tree like datastructure. (where icons are stored!)
- Tool: Resource Hacker
	- Also Ghidra but less effective 
- Used to check for embedded
 data inside of the PE
- Many malware families will embed the (encrypted) configuration file for the malware inside of the resources section
- Always check the resources!


:::

::: right
![[0x03_slide_38_image.png|500]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Symbols/Debugging information
:::

::: left
<!-- element style="font-size: 24px"-->
- Program Database (.pdb) files contain debug and symbol information about portable executables
- When compiled with Mingw, the symbols are 
embedded
 in the exe
- Other times, the PDB is external and the path to it is set in the 
binary
- Ghidra can parse symbols


:::

::: right
![[0x03_slide_39_image.png|220]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### X-Refs

:::

<!-- element style="font-size: 24px"-->
- X-Refs: Cross Reference
- When analyzing code, it can be difficult to determine how to get started 
- Simple questions like “where is the *real* main function?” can be difficult to answer
- Remember, `entry` is not the same thing as the main code
- In fact, if the binary uses SEH, security cookies, and/or a C Runtime, the entry point will NOT be the main function

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### X-Refs: Imports 
:::

::: left
<!-- element style="font-size: 24px"-->
- Right click the function name, and select show references
- This will find all spots in the code that (probably!) are calling this function
- This can help us determine what specific functions are doing!


:::

::: right
![[0x03_slide_41_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### X-Refs
:::

::: left
<!-- element style="font-size: 24px"-->
- Example: finding  references
 to UrlDownloadToFileW to identify a malicious download!

:::

::: right
![[0x03_slide_42_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### X-Refs: Strings
:::
![[0x03_slide_43_image.png|800]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### X-Refs: Strings
:::


![[0x03_slide_44_image.png|900]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reading/editing Assembly 

:::

<!-- element style="font-size: 24px"-->
- Ghidra comes with a pretty decent Decompiler! This converts Assembly into C-like code 
- It also supports interactive 
disassembly
- You can rename functions, modify function signatures, and add comments
- Save your work in a ghidra specific database file

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Reading/editing Assembly 
:::

::: left
<!-- element style="font-size: 24px"-->
- Recommendation
: select a function and click display control flow graph to view program  control flow 

:::

::: right
![[0x03_slide_46_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Reading/editing Assembly 
:::

![[0x03_slide_47_image.png|400]]


---
<!-- slide template="[[Split Vertical]]" -->
::: title
#### Do not upload to VirusTotal 
:::
::: left
<small>WARNING
DO NOT UPLOAD EVERYTHING TO VT! 
- Adversaries Monitor VT
- Virustotal doesn't fully sandbox samples and will distribute binaries to other sandbox services.
- When the malware beacons out to the C2 from VT, this can be detected. Do not tip off your adversary if you can avoid it.  

:::
::: right
![[canary_token_binary.png|300]]
:::
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Finding the actual Main Function

:::

<!-- element style="font-size: 24px"-->
- Malware authors can make this very, very difficult
- In the simple case, where the only functions that come before the main function are startup code for the SEH, C runtime and possible security cookies.
	- Just look for the last 
function
 called in _entry that returns an int.
- Warning
: TLS callbacks are executed before entry and can be used to hide the real entry point
- Finding main: X-refs are your friend!


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: 
3 ways to find the main function!
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### General Tips 

:::

<!-- element style="font-size: 24px"-->
- Look for x-refs to suspicious strings
- Look for x-refs to imported functions 
	- Especially Look for calls to LoadLibrary
- C-style main: int main(int argc, char* argv[]){...}
	- It returns an integer! Look for this!
- Practice finding main! Compile a binary and see if you can find the real entry point!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### When is this  methodology difficult to use?

:::

<!-- element style="font-size: 24px"-->
- Packed Malware, obfuscated code, dynamically resolved imports...etc
- We will spend lots of time on this. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### UPX: So common it is a malicious heuristic
:::

::: left
<!-- element style="font-size: 24px"-->
- fd535b7d6cc6ce5641cdacc96d7ebd25e10ee8bc84c301580be0b55ef6ed787d


:::

::: right
![[0x03_slide_52_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Real world Example: Wannacry
:::

![[0x03_slide_53_image.png|500]]




---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Wannacry
:::

::: left
<!-- element style="font-size: 18px"-->
- Worm + ransomware that leveraged exploits developed by the NSA
- Spread using “eternalblue” that exploited a bug in Microsoft's SMB protocol
- Hundreds of thousands of computers were affected 
- The kill switch , which is a domain name, was discovered by MalwareTech
	- This stopped the spread of the malware, and prevented potentially billions of dollars of damage
- Let’s see if we can recreate that work 

:::

::: right
![[0x03_slide_54_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Finding the killswitch Statically 
:::

::: left
<!-- element style="font-size: 24px"-->
- Strings 
- Pivot to code that references the strings 
- Find function that  calls InternetOpenUrlA
- Notice the branching behavior 


:::

::: right
![[0x03_slide_55_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### How hard is it to find the Killswitch?
:::

::: left
<!-- element style="font-size: 24px"-->
- Not very. It takes more work to understand that it is indeed a killswitch, but hopefully this goes to show you why takes like this are...pretty out there. 

:::

::: right
![[0x03_slide_56_image.png|700]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Discussion: Reading the Documentation

:::

<!-- element style="font-size: 24px"-->
- How do we control different aspects of the Windows OS?
- What exactly is an OS? How is Windows different from say Linux, or IOS?

