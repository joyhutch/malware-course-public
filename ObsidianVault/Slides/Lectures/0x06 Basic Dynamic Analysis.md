---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::



---
<!-- slide template="[[Title Slide]]" -->
 ## Dynamic Analysis
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Lecture 0x06: Dynamic Analysis
:::

::: left
<!-- element style="font-size: 24px"-->
- Dynamic Analysis: Executing (or emulating) code and observing its behavior.
- Usually this requires some amount of  resource introspection in order for it to be useful

:::

::: right
![[0x06_slide_3_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Analysis 

:::

<!-- element style="font-size: 24px"-->
- Examples:
- Attaching a debugger to processes and stepping through execution
- Snapshotting
 an environment, running code, and noteing changes
- Running wireshark and observing network activity 
- Running Procmon/Sysmon and observing code behavior 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Recall: What are we usually interested in?

:::

<!-- element style="font-size: 24px"-->
- Most malware is on a mission: it has some sort of tactical objective. 
- We want to determine what this mission is!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Questions we usually want answered:

:::

<!-- element style="font-size: 20px"-->
![[CommonMalwareQuestions]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Debuggers

:::

<!-- element style="font-size: 24px"-->
- Userland debuggers allows us to debug userland processes 
- Kernel debuggers allow us to debug entire systems
- Hypervisor Debugger: Debug the system from perspective of the hypervisor
- All of the malware in this class will be userland. As such we only need a userland debugger. 
	- That said, if the malware you are looking at lives in kernel space, you will need a kernel debugger
	- Or if the malware can detect userland debugging/hooks
- Debugging allows us to step through execution, examine memory, registers, modify values, and determine application behavior


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### x64dbg
:::

::: left
<!-- element style="font-size: 20px"-->
- While not required, the supported debugger for this class is x64dbg
- Other options include GDB, Visual Studio Debugger (ew), Windbg, 
HyperDbg (in beta but is very, very cool)
- X64dbg runs the processes and 
attaches itself as a debugger
- It is nice for malware analysis as well, as it has some features to hide the presence of the debugger from the perspective fo the debugee 

:::

::: right
![[0x06_slide_8_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Example: ClickMe.exe
:::

<br>
<br>
<center>
![[0x06_slide_27_image.png| 900]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### There is a lot going on…

:::

<!-- element style="font-size: 24px"-->
- Debuggers will show you a **lot** of information
- To better understand what is  
happening, we need to understand some basic information about processes on Windows 


<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Totally lost? That is ok!
:::

::: left
<!-- element style="font-size: 24px"-->
- This is a lot of information to absorb. IMO, the best way to get more comfortable with it is via examples.
- Let’s go back to ClickMe.Exe!


:::

::: right
![[0x06_slide_26_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Example: ClickMe.exe
:::
<br>
<br>
<center>
![[0x06_slide_27_image.png| 900]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### X64dbg Basics 

:::

<!-- element style="font-size: 24px"-->
- Breakpoints: fixed region of executable memory that will pause execution.  
- Run (F9): Run the binary
- Step Into (F7): Step 1 instruction. If the 
instruction
 is a call, step into the function
- Step over (F8): Step 1 instruction. If the instruction is call, execute the function and continue
- Execute Until Return (Ctrl-F9): run the binary 
until
 the next ret instruction
- Execute Until User Code (alt-F9): Run until we are back in the memory 
mapped
 region of our binary (usually the .text secion) 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### X64dbg Basics: Symbols 
:::

::: left
<!-- element style="font-size: 24px"-->
- Symbols can show us all of the loaded DLLs, in addition to where our current Executable is
- Base: base addresses of our executable. 
- Recall that Virtual Memory is effectively a giant array, where the addresses is the offset in that giant array
- The base addresses of our exe is the offset in that giant array


:::

::: right
![[0x06_slide_29_image.png|800]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Memory Map 
:::

::: left
<!-- element style="font-size: 24px"-->
- Either navigate to the memory map view, or right click the relevant PE and click “Follow in memory map”

:::

::: right
![[0x06_slide_30_image.png|800]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Memory Map
:::

::: left
<!-- element style="font-size: 18px"-->
- Shows us everything that is memory mapped in our processes virtual address space 
- We can see all loaded PEs and their sections 
- We can also see their 
memory protections
- Basics: Read, Write Executable 
- Full list: 
https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode
- We can follow in Dump to view the raw bytes 


:::

::: right
![[0x06_slide_31_image.png|700]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### CPU/Disassembler 
:::

::: left
<!-- element style="font-size: 24px"-->
- The CPU tab shows 
disassembly
 instructions based on data stored at the addresses 
- RIP is the instruction pointer
- Supports Line view/graph view
- To switch back and forth press “g” inside of the CPU window


:::

::: right
![[0x06_slide_32_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### CPU: Jump back to next instruction
:::

<!-- element style="font-size: 24px"-->
- You can navigate to any addresses by using the hotkey “Ctrl-g”
	- Note Ctrl-g for jumping in any window: dump, memory map, CPU…etc 
- Note this can be a memory addresses, values stored in a register, or a region for which there is a symbol defined!
- To jump to the current instruction, use RIP
- Note Jump-> `RIP + 1` is also valid! 

<center>

![[0x06_slide_33_image.png|600]]



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Static Analysis to guide dynamic analysis 
:::

::: left
<!-- element style="font-size: 24px"-->
- We should always take a look at the malware statically before running it. 
- Sometimes, it can give us hints about what it is doing 
- Example, look for imports, strings...etc 

:::

::: right
![[0x06_slide_34_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Debugging Workflow   
:::

::: left
<!-- element style="font-size: 18px"-->
- The common workflow is to load the PE into the debugger, and set some breakpoints. 
- x64dbg automatically sets a breakpoint at the entrypoint, but as we have seen, this is NOT the same as the main() 
- Step through the code and see what it does!
	- Will probably take some trial and error! Especially if anti-debugging 
techniques
 are employed.


:::

::: right
![[0x06_slide_35_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Debugging
:::

<!-- element style="font-size: 24px"-->
- Try setting a breakpoint: 
- bp URLDownloadToFileW`
- Then run until we hit the breakpoint!
- What exactly is that address though?
- It is the start address of the exported function `urlmon.dll$
URLDownloadToFileW`

<center>
![[0x06_slide_36_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### What’s going on? Why is nothing happening?
:::
<center>
![[0x06_slide_37_image.png|800]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Debugging: Modifying Arguments
:::

::: left
<!-- element style="font-size: 24px"-->
- `bp Sleep`
- Modify 1st argument to be 0
- → Set RCX = 0
- Or type
- `RCX = 0 ` in the cmd prompt

:::

::: right
![[0x06_slide_38_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::
<center>
![[0x06_slide_39_image.png]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Common Functions to set BPs at

:::

<!-- element style="font-size: 24px"-->
- Win32: VirtualAlloc(Ex), VirtualProtect(Ex), CreateProcess, CreateThread, CreateRemoteThread, LoadLibrary, Sleep
- Native: NtCreateProcess(Ex), NtAllocateVirtualMemory
- Usually better to figure out what functions are used from a bit of static analysis and then go from there :-)
- No imports? Spy on LoadLibrary(A/W)!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Using The Gateway VM

:::

<!-- element style="font-size: 24px"-->
- By setting GatewayVm as the default gateway, we can listen in on network traffic using wireshark and simulate responses using Inetsim
- We can filter for traffic type that we expect the malware to create. 
- I.e, if we see WinHttp, we can filter on HTTP traffic
- If we see Winsock, we might want to look for TCP 
- It is all context dependent.  

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Using Wireshark and Inetsim
:::


![[0x06_slide_42_image.png]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Verdict: Dropper

:::

<!-- element style="font-size: 24px"-->
- This malware is a dropper. It downloads, and 
executes
 a binary from a remote 
web server
- It 
communicates
 over HTTP
- As of Now, it is not clear who or what it is targeting
- However, as we saw last time, the code will not run without `C:\malware\ch0nky.txt`

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Inetsim Default Binaries

:::

<!-- element style="font-size: 24px"-->
- If you make a Get request that ends in *.exe, inetsim will serve a  binary to let you know something has happened! 
- This can be useful for catching stealthier downloads
- You can also set your own default exe that prints more information than just a hello world! I.e. it might be nice to know the parent process, the cwd, ...etc

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Real world Example: Wannacry
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x06_slide_45_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Recap: Wannacry
:::

::: left
<!-- element style="font-size: 18px"-->
- Worm + ransomware that leveraged exploits developed by the NSA
- Spread using “eternalblue” that exploited a bug in Microsoft's SMB protocol
- Hundreds of thousands of computers were affected 
- The kill switch , which is a domain name, was discovered by MalwareTech
	- This stopped the spread of the malware, and prevented potentially billions of dollars of damage
- Let’s see if we can recreate that work 

:::

::: right
![[0x06_slide_46_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Finding the killswitch Statically 
:::

::: left
<!-- element style="font-size: 24px"-->
- Strings 
- Pivot to code that references the strings 
- Find function that  calls InternetOpenUrlA
- Notice the branching behavior 


:::

::: right
![[0x06_slide_47_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### How hard is it to find the Killswitch?
:::

::: left
<!-- element style="font-size: 24px"-->
- Not very. It takes more work to understand that it is indeed a killswitch, but hopefully this goes to show you why takes like this are...pretty out there. 

:::

::: right
![[0x06_slide_48_image.png|800]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Wannacry: Finding the Killswitch Dynamically

:::

<!-- element style="font-size: 24px"-->
- Worm + ransomware that leveraged exploits stolen from the NSA
- Spread using “eternalblue” that 
exploited
 a bug in 
Microsoft's
 SMB protocol
- Hundreds of thousands of computers were affected 
- The kill switch, which is a 
domain name
, was 
discovered
 by MalwareTech
	- This stopped the spread of the malware, and prevented potentially billions of dollars of damage


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Finding the Killswitch: Dynamic Analysis 
:::

![[0x06_slide_50_image.png]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Sandboxes & VirusTotal

:::

<!-- element style="font-size: 24px"-->
- Sandbox: Contained environments with logging / analysis software pre-installed that will allow you to see what the malware actually does. 
- VirusTotal
 (VT): Sandbox, Hunting Environment, and Antivirus detection all in one! 
- Malshare: good repository of malware to download from if your company doesn’t pay for VT premium.  
- Others: Joes Sandbox, Intezer


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DIY Sandbox

:::

<!-- element style="font-size: 24px"-->
- Why would I want to do this?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DIY Sandbox

:::

<!-- element style="font-size: 24px"-->
- Why would I want to do this?
- Anything you upload publicly becomes available publicly.
- Sometimes you don’t want other threat intelligence analysts looking at a threat that is targeting your systems, you might end up on the front page of NYT as the “victim of a cyber attack” and nobody likes that. 
- You also don’t want attackers monitoring for those files on VT to know that you’re on to them, they might start changing their tactics.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DIY Sandbox

:::

<!-- element style="font-size: 24px"-->
- Not only can threat actors monitor for the existence of the hashes, but authors can put canaries/booby traps in the code that tip them off. Example: DNS canaries that get tripped when the bot detects a sandbox
- Where possible you should tread carefully, doing so can slow you down. 
- The choices you make will likely vary depending on the environment you occupy. For example, someone tracking a low and slow APT will likely take their time, whereas someone in a triage environment might have to cut some corners and move faster.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DIY Sandbox

:::

<!-- element style="font-size: 24px"-->
- Remnux / FlareVM
- Steps:
- Take a snapshot
- Run the malware with the desired logging tools
- Log the data elsewhere
- Revert the snapshot
- MAKE SURE NEITHER OF THESE VMs ARE CONNECTED TO YOUR REAL MACHINE OR THE INTERNE


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### **Warning**

:::

<!-- element style="font-size: 24px"-->
- I will say it again. 
- Uploading suspected malware to virustotal should not be your first choice. 
- Only do so if you know it is OK to have the samples publicly disclosed! 
- Setting traps in malware is more common than you would think!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Why doesn’t Dynamic Analysis always work?

:::

<!-- element style="font-size: 24px"-->
- Competent
Malware authors know what malware analysts will look for, and what sandboxes look like. 
- Code can detect that it is inside of a sandbox, and behave differently
- Beware of decoy Executables 
- It would be a shame if you wasted your time looking at a benign binary

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Why doesn’t Dynamic Analysis always work?

:::

<!-- element style="font-size: 24px"-->
- Malware authors know what malware analysts will look for, and what sandboxes look like. 
- Online sandboxes usually stop running after a few minutes or so - the malware can “sleep” for days if programmed to do so. 
- Malware might check for specific configurations / names of sandboxes that are the defaults (sound 
familiar
 ;)?). 
- Malware authors might upload files to VirusTotal / “nodistribute” malware repositories to check against antivirus and tweak the file until there are no hits.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Discussion: 

:::

<!-- element style="font-size: 24px"-->
- How can we make the reverse engineer’s life harder?
- In what situations does the malware author “win”?
- How does your analysis 
environment
 impact 
a reverse engineering 
workflow?
- We will spend 
more
 time on defense evasion in a future lecture. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Triage Environment 
:::

::: left
<!-- element style="font-size: 24px"-->
- New epochs of malware 
arrive
 on your desk
- Most of it probably isn’t that interesting/new. 
- You need to pull 
relevant
 IOCs out and publish them to your stakeholders as soon as possible 
- You might not have time to fully understand every
thing the malware does 
- This is can very quickly turn into a game of 
Whack
Mole


:::

::: right
![[0x06_slide_60_image.png|600]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example: Generic Malspam 

:::

<!-- element style="font-size: 24px"-->
- Many infections are the result of massive 
email
 spam 
campaigns
 (malspam)
- These tend to be wide-net strategies, and typically don’t change much from epoch to epoch
- It might not be worth your time to spend hours 
reversing
 the next iteration of trickbot to realize that it now also targets Chase in addition to BOA. It’s banking malware. You don’t want it on your network!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Research/Investigative Environment 

:::

<!-- element style="font-size: 24px"-->
- Reasons to dedicate large amounts of time to analyzing malware:
- It is 
targeting
 something or 
someone
 interesting
	- Journalists, critical infrastructure, governments, 
dissidents
...etc
	- EG: 
uranium
centrifuges
- It is doing something interesting
	- Leverages 0/N-day exploit, 
sophisticated
 functionality
	- Making uranium 
centrifuges
 spin too fast
- You are constantly being targeted by the same tools and need to develop “effective” countermeasures. 
- It is 
associated
 with an incident that requires remediation.


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Example: Stuxnet
:::

::: left
<!-- element style="font-size: 24px"-->
- A Sophisticated malware used during a (likely) joint US-Israel cyber opteration 
designed
 to disrupt Iran’s Nuclear program
- For more on this, see “Countdown to Zero Day” By Kim Zetter

:::

::: right
![[0x06_slide_63_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## In either case, you probably want to be efficient 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### The Reverse Engineer Always Wins*

:::

<!-- element style="font-size: 24px"-->
- Malware authors will 
employ
variety
 of tricks to slow you down. The more of these tricks you see, the faster you will get at bypassing them.
- With enough time, energy and money you can reverse engineer just about anything
- You don’t have infinite time, money, or resources. Neither does your adversary!
- You will need to automate portions of your work to make the sheer volume  of tasks tractable to complete.

---
<!-- slide template="[[Title Slide]]" -->
 ## Dealing with Tricks 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Discussion 

:::

<!-- element style="font-size: 24px"-->
- How can we detect that we are in VirtualBox?
- Example: 
- `wmic bios get smbiosbiosversion`


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example 2

:::


```powershell
$drivers = Get-WindowsDriver -Online -All
ForEach($d in $drivers){
	if($d.ProviderName -eq "Oracle Corporation"){
		echo $d
	}
```

```


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Discussion: Sandbox Detection

:::
- How can we detect that we are in a sandbox?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Tool: Pafish
:::
- https://github.com/a0rtega/pafish
- ![[pafish.png]]





