---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::



---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x03: 
Introduction to Windows Internals and C programing 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Agenda for Today: Windows Basics

:::

::: left
<!-- element style="font-size: 24px"-->
- Core OS Concepts 
- Basic Windows Internals 
- C and the Windows API

:::

::: right
![[0x02_slide_3_image.png|400]]


:::



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### CrackMe HW Will be up By tomorrow
:::

::: left
<!-- element style="font-size: 18px"-->
- You should get started on this ASAP. 
- In this assignment you will get exposed to CrackMes: puzzles used to practice your reverse engineering skills!
- The goal is simple: Find the input that makes the binary print “Cracked!”
- In this assignment you will get comfortable staring at some basic assembly, and finding the main function when a C-runtime is used.
- You don’t have to ever run the binary, but you can to verify your answer!


:::

::: right
![[0x04_slide_77_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Get started soon!
:::

::: left
<!-- element style="font-size: 24px"-->
- If you don’t have previous reverse engineering experience, you probably can’t do this homework the night before it is due!
- Get started ASAP: it is difficult to predict where you will get stuck!
- None of the CrackMes are designed to trick you per say, but they might not be straight forward!


:::

::: right
![[0x04_slide_78_image.png|250]]


:::


---
<!-- slide template="[[Title Slide]]" -->
 ## The Windows Operating System
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What is an Operating System

:::

<!-- element style="font-size: 24px"-->
- A fancy resource manager. 
- It abstracts away the managing of physical devices (CPU, Memory, I/O devices…etc)
- The core mechanism for abstracting away resources is *virtualizaion*
- This is effectively a level of indirection and an exported interface 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Operating System Kernel 

:::

<!-- element style="font-size: 24px"-->
- Responsible for servicing requests and translating them into instructions compatible with computer hardware including the CPU, Memory, I/O devices…etc
- Often provides an interface for userland applications to interact indirectly with resources

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### The Windows Operating System

:::

<!-- element style="font-size: 24px"-->
- Proprietary Operating System Developed by Microsoft 
- Multi Arch: 32/64 bit, preemptive multitasking operating system
- Primary flavors are Client, Server  
	- Others include IOT, CE, Xbox, Some defunct targeting mobile…etc
- We will focus on Windows (10) Client/Server

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Devices that run Windows

:::

<!-- element style="font-size: 24px"-->
- Desktop computers
- Servers
- Laptops
- Tablets
- XBox (technically a fork of Windows 2000)
- Different devices have different considerations (battery, screen size, memory, storage …etc)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### (Some) Windows Design Principles

:::

<!-- element style="font-size: 24px"-->
- Extensibility
- Portability
- Reliability  
- Performance
- Compatibility
- Security 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Extensibility 



:::

<!-- element style="font-size: 24px"-->
- The bulk of system services are provided by the Executive
- The Windows OS is technically a Hybrid Kernel but...
	- One driver can mess with another driver. Kernel memory is shared 
- Separates  userland execution 
environments into “subsystems”
- Each subsystem has the ability to execute a type of application
- This provides a modular setup where changes to execution environments
 don’t necessarily necessitate changes to the executive 



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Portability

:::

<!-- element style="font-size: 24px"-->
- Windows will run on a wide variety of systems. 
- The bulk of the OS is written in C and C++
	- The rest is bundles of code used for processor specific instructions (Eg Arm vs intel/amd)
- Platform dependent code is implemented in the Hardware Abstraction Layer (HAL)
- This is less magical than it was 10 years ago as most modern OSes support variety in hardware/architecture


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reliability

:::

<!-- element style="font-size: 24px"-->
- User applications should not be able to corrupt the operating system
- Windows audits most drivers and has rigorous standards for which drivers are officially signed
- That said, malicious drivers can muck around with kernel memory. There are countermeasures for this. (eg Driver Guard) but they are mitigations.

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Performance
:::

::: left
<!-- element style="font-size: 24px"-->
- Should be fast. :shrug:
- async I/O
- Multi threaded

:::

::: right
![[0x02_slide_13_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compatibility

:::

<!-- element style="font-size: 24px"-->
- Backwards compatibility and extending of existing technology
- This is partially why the Windows API is so stable 
- You do not get this kind of stability with Linux
- NTAPI vs Windows API

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Security

:::

<!-- element style="font-size: 24px"-->
- Kernel/User separation 
- User/User separation
- Process (and associated resources) isolation 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows Kernel

:::

<!-- element style="font-size: 24px"-->
- Windows is an Object based kernel
- Resources are called objects, and can only be directly accessed by the kernel
- To indirectly interact with an object, a 
handle
 is used

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel Objects

:::

<!-- element style="font-size: 24px"-->
- Kernel object (KOs): a single run-time instance of a statically defined object type 
- Object types are system-defined data types. 
- Each object type has its own attributes and functions to interact with it
- For example, an object of type 
process 
is an instance of a process object.
- file 
object is an instance of a file. Note, 
file!= a thing on disk


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Objects and Handles 

:::

<!-- element style="font-size: 24px"-->
- A handle is an abstract reference to an object. This could be an actual pointer to the object, or a reference to a per-process GUID that references an object
- This allows us to abstract away direct management of objects in memory, and instead work with with references. 
This is a security control. If something goes wrong in kernel space, you get a BSOD. 
- APIs are used to interact with system resources, share resources among processes, and protect resources from unauthorized access.


---
<!-- slide template="[[Title Slide]]" -->
 ## Processes
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Processes

:::

<!-- element style="font-size: 24px"-->
- Nothing in userland is executed outside of the context of a process.
- You don’t “run a processes”
- You run threads 
- Processes are containers around resources required to run a program
- There is no such thing (to my knowledge) as code running outside of a process in userland

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Threads 

:::

<!-- element style="font-size: 24px"-->
- Unit of execution contained within a process.
- Actual entity that executes code 
- More on threads in later. For now, we will only deal with processes that have a single executing thread.
- "Virtualizing the CPU"


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Process Resources 
:::

::: left
<!-- element style="font-size: 24px"-->
- Uniquely identified by a Process ID
- Contains a security context in the form of a Process Access Token
- Maintains a table of handles to objects
- Has a private virtual address space 
- \>=1 Thread (possibly with its own token)

:::

::: right
![[0x02_slide_46_image.png|400]]


:::



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Random Access Memory
:::
<!-- element style="font-size: 24px"-->
- Physical Memory: a linear byte-array of byte addressable data
	- I.e., a giant list of binary data where we can 
	- Q: Ignoring extensions, if we have byte addressable arrays and we can use 64 bit integers (8 bytes) to address the array, what is the maximum number of bytes we can support? 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Virtual Memory

:::

<!-- element style="font-size: 24px"-->
- An abstraction layer around physical memory
- Each process gets its own private virtual memory 
- $2^{32}$ bytes worth on 32 bit (possibly more with some extensions) 
- $2^{64}$ bytes worth on 64 bit
- The kernel lies about how much space there really is
- Think of a virtual address space as a giant, contiguous array of bytes


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Process Virtual Memory
:::

::: left
<!-- element style="font-size: 24px"-->
- Windows  implements a linear Virtual Address space
- Provides a logical interface for a process to interact with indirectly with 
physical memory as if it were one giant array of bytes

:::

::: right
![[0x02_slide_48_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Virtual Memory Concepts

:::
- Page Tables
- Page Table entries 
- Virtual Address Descriptors
- Byte Addressable
- Hardware assistance (walking the page table)
- 32bit/64bit
- Memory Protections
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Memory Layout	
:::

::: left
<!-- element style="font-size: 20px"-->
- Each processes gets its own Virtual Address Space
- The Windows OS divides Virtual Address space into  two portions: kernel and Userland*
- Memory here grows “downward” from higher address spaces to lower address spaces
- On x64, the upper half is reserved for kernel space and the bottom half is reserved for processes

:::

::: right
![[0x02_slide_49_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory

:::

<!-- element style="font-size: 24px"-->
- Virtual: A Block of raw memory 
- Stack: technically can be managed by the programmer but is usually managed by the processes and the compiler
- Heap Memory: managed by the programer with a special data structure called a Heap 
	- Basically a priority queue


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Disk	
:::
<!-- element style="font-size: 24px"-->
- considerably slower storage
- Cheaper than RAM
- Similar to memory, it is a block of linear storage. 
- Usually interacting with the disk is implemented via a driver that helps implement a filesystem
- Example: NTFS, EXT4 FAT32
- Disk: Flash, hard disk/CD, SSD, magnetic tape...etc

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows System Architecture

:::

<!-- element style="font-size: 24px"-->
- User Processes
- Subsystem DLLs
- NTDLL.dll
- Service Processes
- Executive
- Kernel 
- Device Drivers
- Win32k.sys
- (sometimes) Hyper-V


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interacting with the Windows OS

:::

<!-- element style="font-size: 20px"-->
- Windows API functions (win32): Documented, callable functions in the Windows API. 
	- For example, MessageBox, CreateFile, GetMessage
- Native system services (sys calls): Undocumented (officially) underlying serivices in the OS that are callable from user mdode. For example 
	- NtAllocateVirtualMemory is the internal service used for VirtualAlloc 
	- NtCreateUserProcess is the internal service used by CreateProcess
- Direct Syscalls
- Other:  (WinRT, COM,...etc)
- Kernel support functions: functions inside the Windows OS that can only be called from in kernel mode

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interacting with Windows

:::

Most of the Windows API is implemented in a handfull of  DLLs

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamically Linked Libraries: 

:::

<!-- element style="font-size: 24px"-->
 #### Refresh: What is a DLL?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DLL

:::

<!-- element style="font-size: 24px"-->
- A PE with with DLL characteristic field set. 
- Usually it has exported functions which can be referenced by code outside of the DLL

#### Again: The Windows API is implemented in a handful of DLLs that export specific functions

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Win32 API	

:::

<!-- element style="font-size: 24px"-->
- We will mostly leverage documented functions from the Windows API
- The function definitions are well documented
- Reading that documentation however, is a skill that must be learned
- Sometimes, we need more control over what we are trying to accomplish, and will leverage undocumented functions stored in NTDLL.dll


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NtDLL.dll	

:::

<!-- element style="font-size: 24px"-->
- Implements the Windows Native API. This is the lowest layer of code that is still Userland code. 
- It is used to communicate with the kernel for system call invocation. 
- NtDLL also implements the Heap Manager, the (executable) Image loader and some of userland thread pools. Every process loads this DLL in the same location in memory! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel32.dll

:::

<!-- element style="font-size: 24px"-->
- Contains (more or less) the same functionality as NtDLL!
- It exposes basic operations such as memory management, input/output (I/O) operations, process and thread creation, and synchronization functions
- It can be thought of as a compatibility layer, as it almost always calls directly into NTDLL.dll
- This is to maintain backwards compatibility– where the Win32 API rarely changes, but the Native API changes from release to release.


---
<!-- slide template="[[Title Slide]]" -->
How do we interact with the Window's API?
---
<iframe width="1180" height="664" src="https://www.youtube.com/embed/toSm_flWhyE?start=20&end=32" title="Sesame Street: Letter C (Letter of the Day)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
 
---
<!-- slide template="[[Base Slide]]" -->
::: title
####  C Overview 

:::

<!-- element style="font-size: 24px"-->
- C/C++ is a statically typed, compiled programing language 
- A large portion of malware you will encounter is written in C/C++
- C/C++ has no Garbage collector:
	- This Forces the developer to manage their own memory
- While it is general purpose, we will use it as a systems programing language
- C++ has many different versions, many different compilers and tools to help with debugging


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Concepts you need to know for this class

:::

<!-- element style="font-size: 24px"-->
- Memory  management with C/C++
- Pointer Arithmetic 
- Basic C types 
-  Note these are prerequisites

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compiler toolchain for this class

:::

<!-- element style="font-size: 24px"-->
- For this class you may choose one of the following:
- MinGW (GNU gcc/g++ compiler)
	- Minimal GNU GCC on Windows
- clang/clang++
	-   Compiler toolchain built on top of LLVM
- zig C/C++ compiler 
	- Technically, zig is itself a 
programming
 language that is built on top of llvm. It provides a drop in 
replacement
 for most C/C++ compilers and provides cross compilation out of the box! It also tends to create smaller, more hackable builds as it supports directly 
emitting
 LLVM (not covered in this class, but you should 
definitely
 check it out!)
- In either case, we will use GNU Make to simplify 
the build process 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Development tools

:::

<!-- element style="font-size: 24px"-->
- We will use Visual Studio Code (blue, not purple program) as our IDE
	- Feel free to install c/c++ 
intellisense
 tools to get tab completion
- The officially supported compiler will be Mingw (gcc/g++)
- clang/Clang++, which is in most cases a drop in replacement, is also supported, and preferable when leveraging 
certain
 C++ Std libs.
	- Threading with mingw doesn’t always work/isn’t always supported :)
- For 
Debugging
, we will use x64dbg
- For analyzing the executable statically, we will use a combination of PE-Bear and Ghidra


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Why not Visual Studio?	

:::

<!-- element style="font-size: 24px"-->
- Windows has an official C compiler: cl.exe 
- Visual Studio IDE + cl.exe does not easily support cross compilation (i.e., compiling our code on a Linux machine targeting a windows machine)
- Windows is a pretty “heavy” OS in that it is not as cheap to deploy as a linux box. 
- For Tailored payloads, having a build server that can be run on any Linux machine is an incredibly attractive feature for our purposes
- ...It also makes grading easier/possible :D
- ...Also I don’t like .sln (Solution) files (build files used by Visual Studio) 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### ...Also
:::

::: left
<!-- element style="font-size: 24px"-->
- It can run slowly in a VM and is very memory hungry.
- Kidding aside, it is an incredible IDE, and the standard in industry for large scale software development.
- This class doesn’t cover it.
- I also on principal hate all Microsoft products that have “Enterprise” in the name.

:::

::: right
![[0x04_slide_15_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Why Visual Studio?	


:::

<!-- element style="font-size: 24px"-->
- It is a lot easier to target **all** versions of Windows
- VS has a powerful debugger (you can set source code breakpoints!)
- Windows Driver Kit plays better with VS
- VCPKG
- Easier to test


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### C, Microsoft Visual C, and C Runtimes 

:::

<!-- element style="font-size: 24px"-->
- C is a 
programming
 language specification
- It is implementation dependent!  
- Similar to LibC on Linux, Windows has a C runtime environment called the Microsoft Visual C Runtime
- This is different from the C 
programming
 language, and is usually compiler/implementation specific. 
- This gives you access to standard functions 
- Visual C != C, but they are very similar, and let you program basically the same way.
- Visual C has 
different
 compiler/linker directives  
	- This means you might have to modify Microsoft example code for it to run with Mingw/clang


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Hello World! Posix style  

:::
```c
#include <stdio.h>

int main(){
	printf("Hello world!\n");
	return 0;
}
```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Hello World: Win32

:::

```c
#include <windows.h>

const char message[] = "Hello world!\n";


int main(){
    // Message
    // Message size in bytes, not including the NULL-Byte
    DWORD messageSize = 13;
    DWORD dwBytesWritten = 0;

    // get Handle to STD_OUTPUT
    HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    WriteFile(
        stdOut, 
        message,
        messageSize,
        &dwBytesWritten,
        NULL
    );
    return 0;
}
```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### WTH: that is so much more code!

:::

<!-- element style="font-size: 24px"-->
- C-Runtimes abstract away details of utilizing OS 
provided APIs for interacting with system resources and objects 
- The text you observe when running a terminal application is actually displaying content from STDOUT, STDERR and takes inputs from STDIN
- We will discuss more about windows internals later, but everything is accessed by 
handles
- For those familiar with Linux internals, a handle fulfils more or less the same role as a Binary File Descriptor
- Under the hood, printf will also get a handle to Standard output and push data to it! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interop: Libc and MSVC

:::

<!-- element style="font-size: 24px"-->
- Most functions implemented in Libc’s stdlib are also implemented in MSVCR (Microsoft Visual C Runtime) 
- Using the stdlib adds a (tiny) amount of overhead

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Entry Point:

:::

<!-- element style="font-size: 24px"-->
- Process creation is a very complex topic, and has many moving parts
- From last class, you should know that the OS performs a sequence of operations, and if there are no errors at the end, the loader will pass execution of the process to the 
entry point
- This is the 
first
 bit of user defined code that is executed when the process starts 
- This will look different depending on what 
type
 of executable we create! Windows supports executables targeting different 
subsystems
- We will focus on 
console
 applications for this lecture.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Code Sample 0:

:::

<!-- element style="font-size: 24px"-->
- The C-Runtime is used by most executables, and as a result most compiler toolchains will call the C runtime startup code by default!
- In this example, we will compile a simple hello world program with and without it!
- Just like in Linux, the executables produced by our compilers have support for debugging information: in 
particular
, we can view the symbols associated with the generated assembly code 
- Let’s take a look at this!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Fundamental Concepts For this class

:::

<!-- element style="font-size: 24px"-->
- C/C++ Runtime
- Windows API
	- Win32 API
	- Native API
	- More undocumented APIs
- If time permits:
	- Component Object Model 
	- Common Language Runtime
	- The Windows Runtime


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Ghidra

:::

<!-- element style="font-size: 24px"-->
- Interactive 
Disassembler
- Has a decompiler 
- Other tools useful for reverse engineering that we will cover another time
- Developed by the NSA. 
- It is free, and fully open source!
- The alternative is IDA  (interactive 
Disassembler
) that costs ~$10k
	- Update… now it is only 5k a year but you only get it so long as you pay for it.Shout out to Hex-Rays for putting a 5MB maximum on 
binaries for students
, and going the Adobe cloud route for SAAS.  -_-...
- Let’s use Ghidra to take a look at what our compiler produced!


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo 0: Hello world
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What exactly just happened?

:::

<!-- element style="font-size: 24px"-->
- What does gcc/g++/zig cc/clang/cl.exe actually do to our source code files?
- Compiling 
- Linking 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Converting Text Programs into Executables	

:::

<!-- element style="font-size: 24px"-->
- What is a C/C++ compiler toolchain responsible for? Converting text (code) into an application that a computer can run! 
- This is 
accomplished
 with two operations. 
- Compiling: 
- Linking:


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compiling: Seriously oversimplified  

:::

<!-- element style="font-size: 24px"-->
- Convert text file into an intermediate file called an 
object file
	- Object files contain assembled code! 
	- If you are using LLVM, this is a little more complicated
- The compiler evaluates “preprocesses” steps
- Constructs an abstract 
syntax
 tree from our code
- From there it can actually generate machine code that the CPU will execute using its backend assembler 
- It also creates a location to store constant data 
- The end result of this stage are “Object files”

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Linking: Seriously oversimplified 

:::

<!-- element style="font-size: 24px"-->
- Once we compile source files, we need to “link” the binary 
- The linker finds where each symbol and function is, and links them 
together!
	- Ie:  the linker replaces  the references to undefined symbols with the correct addresses
- This is an attractive feature, as if there is lots of code reuse across multiple binaries, we can store the 
referenced
 code in a 
library
- There are multiple ways to link against external code 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Linking 

:::

<!-- element style="font-size: 24px"-->
- Static Linking: The external code is directly 
embedded
 in 
your final executable. This can be useful if you are unsure if the user running your code will have the dependencies!
- Dynamic Linking: The reference to the external library is set in your binary, and at runtime, it loads the external library! This gives you smaller binaries, and allows for lots of code reuse!
- I will quiz you on this.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Link Libraries (DLLS)	

:::

<!-- element style="font-size: 24px"-->
- DLLs are analogous to Linux Shared Objects (SOs)
- They are portable executables that contain exported, callable functions that can be dynamically loaded at run time. 
- Some notable ones being 
- NTDLL.dll: core functionality for talking with the kernel
- kernel32.dll (one of the API subsystem libraries)
- Advapi.dll (another one of the API subsystem libraries)l
- Msvcrt.dll (c runtime libraries)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Linking 

:::

<!-- element style="font-size: 24px"-->
- Implicit Linking: 
The program declares in the binary that it wants the OS’s PE Loader to resolve it’s dependencies
- If the PE loader cannot find the dependency, the program exits. 
- Explicit Linking:
 The programer explicitly loads the 
dependency
 at run time, and if it is unable to find the library, it can choose how to respond


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compiling and Linking 

:::

<!-- element style="font-size: 24px"-->
- Compiler 
front ends
 like gcc/g++/clang/zig perform compilation and linking in 1 step
- You can pass options to the linker
- You can direct the linker to link against a dll named DllName with  `-lDllName`
- Because most binaries use Kernel32.dll, it is usually automatically  linked against 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interacting with the Windows OS

:::

<!-- element style="font-size: 24px"-->
- Windows API functions (win32): Documented, callable functions in the Windows API. For example, MessageBox, CreateFile, GetMessage
- Native system services (sys calls): Undocumented (officially) underlying serivices in the OS that are callable from user mdode. For example 
	- NtAllocateVirtualMemory is the internal service used for 
VirtualAlloc
	- NtCreateUserProcess is the internal service used by CreateProcess
- Kernel support 
functions: functions inside the Windows OS that can only be called from in kernel mode

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NtDLL.dll	

:::

<!-- element style="font-size: 24px"-->
- Implements the Windows Native API. This is the 
lowest
 layer of code that is still Userland code. 
- It is used to communicate with the 
kernel
 for system call invocation. 
- NtDLL also imp
lements the Heap Manager, the (executable) Image 
loader
 and some of userland thread pools. Every process loads this DLL in the same location in memory! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel32.dll

:::

<!-- element style="font-size: 24px"-->
- Contains (more or less) the same functionality as NtDLL!
- It exposes basic operations such as 
memory management, input/output (I/O) operations, process and thread creation, and synchronization functions
- It can be thought of as a 
compatibility
 layer, as it almost always calls directly into NTDLL.dll
- This is to maintain backwards compatibility– where the Win32 API rarely changes, but the Native API changes from release to release.



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Win32 API	

:::

<!-- element style="font-size: 24px"-->
- We will mostly leverage documented functions from the Windows API- The function definitions are well documented
- Reading that documentation however, is a skill that must be learned
- Sometimes, we need more control over what we are trying to accomplish, and will leverage undocumented functions stored in NTDLL.dll


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Highlight of Win32 Data Types

:::

<!-- element style="font-size: 24px"-->
- WORD: 16-bit unsigned integer
- DWORD (Double word): 32-bit unsigned integer
- QWORD (Quad word): 64-bit unsigned integer
- LPCSTR: Pointer to a c string (null terminated)
	- Each character is a char
- LPCWSTR:  Pointer to wide character c string (double null terminated)
	- Each character is a wchar
- BYTE: unsigned char
- LPVOID: Pointer to any type
- HANDLE: Handle object
- RTFM as needed: 
https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example: Popping a message box

:::
```c
#include <windows.h>

int main(){
    MessageBoxA(NULL, "Hello there!", "I am a message box!", MB_OK);
    return 0;
}
```

---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: 
Compiling the example and linking against User32.dll
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Reading the docs
:::

::: left
<!-- element style="font-size: 20px"-->
- Debugging your code for 8 hours can save you 5 minutes of reading the docs
	- I myself, routinely don’t read the documentation and suffer for it. Be better than me. Learn from my mistakes. RTFM
- Example:
https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa

:::

::: right
![[0x04_slide_42_image.png|300]]
![[0x04_slide_42_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Strings in Windows 
:::

::: left
<!-- element style="font-size: 20px"-->
- In C, strings aren’t official types. They are simply char pointers to data that is null terminated. These strings are typically UTF-8 encoded but not always! On Windows, they are ANSI  
- This is great when we need the memory footprint of strings to be small, but has two problems
- Doesn’t allow for random access
- Doesn’t support all characters  (Chinese, Russian...etc)
	- This a problem for us. Why? :-)?
	- `*(x +1) == x[1]

:::

::: right
![[0x04_slide_43_image.png|400]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Strings in Windows Continued	

:::

<!-- element style="font-size: 24px"-->
- C/C++ runtimes for windows supports both ANSI and UNICODE UTF-16 characters
- It is generally preferable to use UTF-16 characters with a few exceptions 
- Each character set has its own set of strings functions (strlen, strcpy, strcat...etc) and wslen,,wscat...etc for so called wide-character c strings

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Expansion macros

:::

<!-- element style="font-size: 24px"-->
- Win32 API has a convenience macro for most functions it defines that require strings as arguments. 
- The suffix will be either an A for ANSI or W for wide character Unicode 
	- For example, GetComputerNameA will return an ANSI string, GetComputerNameW will return a UNICODE string
	- Also, MessageBoxA displays ANSI characters, where as MessageBoxW displays unicode!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### TCHAR type

:::

<!-- element style="font-size: 24px"-->
- Similarly, Windows provides the TCHAR macro to expand to either char  or wchar_t type 
- Chars are 1 byte each  ( 8 bits)
- Wchars are 2 bytes each (16 bits)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### String literals 

:::

<!-- element style="font-size: 24px"-->
- By default, string literals are ANSI c strings, but by appending an L to the beginning of the literal, the compiler will define it as a wide character string literal 
- If you want it to work for either depending on the encoding of the application,  the TEXT() macro can be used 
- We will talk about this next time when we discuss WinMain vs wWinMain (take a guess at what it is used for :))


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### General Advice for Strings

:::

<!-- element style="font-size: 20px"-->
- For this class, you are more than welcome to only use the Unicode functions. 
	- In fact, when most versions of Windows call  FunctionA (ANSI), the inputs are converted to unicode and passed to FunctionW (Unicode)
- If your entry point is named main, it will default to ANSI
- If your entry point is named wmain, it will default to Unicode using VisualStudio but since we are using Zig c++ /g++ you  must explicitly pass -municode as a compile flag


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### General Advice for Strings

:::

<!-- element style="font-size:  20px"-->
- If your entry point is named _tmain it will check whether or not UNICODE is defined
- You may only use one of the following from the standard c++ library:
	- cout/ wcout  (Calling both can lead to undefined behavior) 
	- I personally just stick to printf/wprintf though 
- We will revisit this when we talk about C2 Channels, as this will be a become a bit of a headache.
- For more see 
https://docs.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings


---
<!-- slide template="[[Title Slide]]" -->
#### Next time: More o n 
- DLLs
- compiling /linking 
- x86-64 crash course
- Calling Conventions