---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x04: 
C, C++ and Static Analysis 
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Agenda for This Lecture
:::

::: left
<!-- element style="font-size: 24px"-->
- C/C++ on Windows
- Ghidra 
- WinApi
- GCC, Mingw, Zig/clang
- Assembly, x86/x64
- Calling Conventions

:::

::: right
![[0x05_slide_3_image.jpg|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Converting Text Programs into Executables	

:::

<!-- element style="font-size: 24px"-->
- What is a C/C++ compiler toolchain responsible for? Converting text (code) into an application that a computer can run! 
- This is 
accomplished
 with two operations. 
- Compiling: 
- Linking:


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compiling: Seriously oversimplified  

:::

<!-- element style="font-size: 24px"-->
- Convert text file into an intermediate file called an 
object file
	- Object files contain assembled code! 
	- If you are using LLVM, this is a little more complicated
- The compiler evaluates “preprocesses” steps
- Constructs an abstract 
syntax
 tree from our code
- From there it can actually generate machine code that the CPU will execute using its backend assembler 
- It also creates a location to store constant data 
- The end result of this stage are “Object files”

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Linking: Seriously oversimplified 

:::

<!-- element style="font-size: 24px"-->
- Once we compile source files, we need to “link” the binary 
- The linker finds where each symbol and function is, and links them 
together!
	- Ie:  the linker replaces  the references to undefined symbols with the correct addresses
- This is an attractive feature, as if there is lots of code reuse across multiple binaries, we can store the 
referenced
 code in a 
library
- There are multiple ways to link against external code 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Linking 

:::

<!-- element style="font-size: 24px"-->
- Static Linking: The external code is directly 
embedded
 in 
your final executable. This can be useful if you are unsure if the user running your code will have the dependencies!
- Dynamic Linking: The reference to the external library is set in your binary, and at runtime, it loads the external library! This gives you smaller binaries, and allows for lots of code reuse!
- I will quiz you on this.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Link Libraries (DLLS)	

:::

<!-- element style="font-size: 24px"-->
- DLLs are analogous to Linux Shared Objects (SOs)
- They are portable executables that contain exported, callable functions that can be dynamically loaded at run time. 
- Some notable ones being 
- NTDLL.dll: core functionality for talking with the kernel
- kernel32.dll (one of the API subsystem libraries)
- Advapi.dll (another one of the API subsystem libraries)l
- Msvcrt.dll (c runtime libraries)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Linking 

:::

<!-- element style="font-size: 24px"-->
- Implicit Linking: 
The program declares in the binary that it wants the OS’s PE Loader to resolve it’s dependencies
- If the PE loader cannot find the dependency, the program exits. 
- Explicit Linking:
 The programer explicitly loads the 
dependency
 at run time, and if it is unable to find the library, it can choose how to respond


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Example of a crash: 
:::

::: left
<!-- element style="font-size: 24px"-->
- Double click an EXE with a missing dependency, and you will likely see a message like this:
- This happens when an exe is implicitly linked against a missing DLL
- …Hint Hint Nudge Nudge…
- You might need a bit of programming for 1 of the crackmes!

:::

::: right
![[0x05_slide_10_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x05_slide_11_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compiling and Linking 

:::

<!-- element style="font-size: 24px"-->
- Compiler 
front ends
 like gcc/g++/clang/zig perform compilation and linking in 1 step
- You can pass options to the linker
- You can direct the linker to link against a dll named DllName with  `-lDllName`
- Because most binaries use Kernel32.dll, it is usually automatically  linked against 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interacting with the Windows OS

:::

<!-- element style="font-size: 24px"-->
- Windows API functions (win32): Documented, callable functions in the Windows API. For example, MessageBox, CreateFile, GetMessage
- Native system services (sys calls): Undocumented (officially) underlying serivices in the OS that are callable from user mdode. For example 
	- NtAllocateVirtualMemory is the internal service used for 
VirtualAlloc
	- NtCreateUserProcess is the internal service used by CreateProcess
- Kernel support 
functions: functions inside the Windows OS that can only be called from in kernel mode

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NtDLL.dll	

:::

<!-- element style="font-size: 24px"-->
- Implements the Windows Native API. This is the 
lowest
 layer of code that is still Userland code. 
- It is used to communicate with the 
kernel
 for system call invocation. 
- NtDLL also imp
lements the Heap Manager, the (executable) Image 
loader
 and some of userland thread pools. Every process loads this DLL in the same location in memory! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel32.dll

:::

<!-- element style="font-size: 24px"-->
- Contains (more or less) the same functionality as NtDLL!
- It exposes basic operations such as 
memory management, input/output (I/O) operations, process and thread creation, and synchronization functions
- It can be thought of as a 
compatibility
 layer, as it almost always calls directly into NTDLL.dll
- This is to maintain backwards compatibility– where the Win32 API rarely changes, but the Native API changes from release to release.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### MSVCRT.dll

:::

<!-- element style="font-size: 24px"-->
- Implements the C Runtime for Windows. More or less a drop in replacement for many functions found in stdlib.h/stdio.h  


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Win32 API	

:::

<!-- element style="font-size: 24px"-->
- We will mostly leverage documented functions from the Windows API
- The function definitions are well documented
- Reading that documentation however, is a skill that must be learned
- Sometimes, we need more control over what we are trying to accomplish, and will leverage undocumented functions stored in NTDLL.dll


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Highlight of Win32 Data Types

:::

<!-- element style="font-size: 24px"-->
- WORD: 16-bit unsigned integer
- DWORD (Double word): 32-bit unsigned integer
- QWORD (Quad word): 64-bit unsigned integer
- LPCSTR: Pointer to a c string (null terminated)
	- Each character is a char
- LPCWSTR:  Pointer to wide character c string (double null terminated)
	- Each character is a wchar
- BYTE: unsigned char
- LPVOID: Pointer to any type
- HANDLE: Handle object
- RTFM as needed: 
https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example: Popping a message box

:::

```

#include
<windows.h>
int main(){
 MessageBoxA(
	NULL,
"Hello there",
"General Kenobi",
MB_OK,);
return 0;
}
```

---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: 
Compiling the example and linking against User32.dll
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Reading the docs
:::

::: left
<!-- element style="font-size: 24px"-->
- Debugging your code for 8 hours can save you 5 minutes of reading the docs
	- I myself, routinely don’t read the documentation and suffer for it. Be better than me. Learn from my mistakes. RTFM
- Example:
https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa

:::

::: right
![[0x05_slide_21_image.png|300]]
![[0x05_slide_21_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Strings in Windows 
:::

::: left
<!-- element style="font-size: 20px"-->
- In C, strings aren’t official types. They are simply char pointers to data that is null terminated. These strings are typically UTF-8 encoded but not always! On Windows, they are ANSI  
- This is great when we need the memory footprint of strings to be small, but has two problems
- Doesn’t allow for random access
- Doesn’t support all characters  (Chinese, Russian...etc)
	- This a problem for us. Why? :-)?
	- *(x +1) == x[1]

:::

::: right
![[0x05_slide_22_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Strings in Windows Continued	

:::

<!-- element style="font-size: 24px"-->
- C/C++ runtimes for windows supports both ANSI and UNICODE UTF-16 characters
- It is generally preferable to use UTF-16 characters with a few exceptions 
- Each character set has its own set of strings functions (strlen, strcpy, strcat...etc) and wslen,,wscat...etc for so called wide-character c strings

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Expansion macros

:::

<!-- element style="font-size: 24px"-->
- Win32 API has a convenience macro for most functions it defines that require strings as arguments. 
- The suffix will be either an A for ANSI or W for wide character Unicode 
	- For example, GetComputerNameA will return an ANSI string, GetComputerNameW will return a UNICODE string
	- Also, MessageBoxA displays ANSI characters, where as MessageBoxW displays unicode!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### TCHAR type

:::

<!-- element style="font-size: 24px"-->
- Similarly, Windows provides the TCHAR macro to expand to either char  or wchar_t type 
- Chars are 1 byte each  ( 8 bits)
- Wchars are 2 bytes each (16 bits)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### String literals 

:::

<!-- element style="font-size: 24px"-->
- By default, string literals are ANSI c strings, but by appending an L to the beginning of the literal, the compiler will define it as a wide character string literal 
- If you want it to work for either depending on the encoding of the application,  the TEXT() macro can be used 
- We will talk about this next time when we discuss WinMain vs wWinMain (take a guess at what it is used for :))

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Coding conventions for this class

:::

<!-- element style="font-size: 24px"-->
- Windows API functions are prefixed by a double colon
- Type names use Pascal casing (Example PascalCasing)
- Private functions/elements in a class start with an underscore
- Function names are also Pascal casing
- We will use the C++ standard library for common types such as vectors/strings
- Try to keep functions shorter than 20 lines of code but I won’t enforce this. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### C++ usage in this class

:::

<!-- element style="font-size: 24px"-->
- This is not a class on C++ or C. You are expected to know the basic of one or both. However, we will make use of the following features of C++ as we develop code 
- For the final project, you can use C++
- Nullptr: Useful for NULL pointer
- auto: Type inference  
- new/delete: memory management 
- Smart pointers: memory management
- Classes,  Scoping, Templates
- (Pure) Virtual Functions: making our malware modular :)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### General Advice for Strings

:::

<!-- element style="font-size: 20px"-->
- For this class, you are more than welcome to only use the Unicode functions. 
	- In fact, when most versions of Windows call  FunctionA (ANSI), the inputs are converted to unicode and passed to FunctionW (Unicode)
- If your entry point is named main, it will default to ANSI
- If your entry point is named wmain, it will default to Unicode using VisualStudio but since we are using Zig c++ /g++ you  must explicitly pass -municode as a compile flag
- If your entry point is named _tmain it will check whether or not UNICODE is defined
- I personally just stick to printf/wprintf though 
- We will revisit this when we talk about C2 Channels, as this will be a become a bit of a headache.
- For more see 
https://docs.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### X86-64 Assembly Crash Course
:::

::: left
<!-- element style="font-size: 24px"-->
- Assembly language is machine specific code that is executed directly by a processor
- X64 (amd64) is an extension of 32bit x86
- It contains 16 general purpose registers: 
RAX
RBX
RCX
RDX
RBP
RSI
RDI
and
 RSP, R8
R15
- Note: You are expected to be familiar with x86 assembly


:::

::: right
![[0x05_slide_30_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Registers by Name

:::

<!-- element style="font-size: 24px"-->
- RAX - register a extended. Usually return register for integers
- RBX - register b extended 
- RCX - register c extended 
- RDX - register d extended
- RBP - register base pointer (start of stack) (32bit: EBP) (unless your code is optimized :-) 
- RSP - register stack pointer (current location in stack, growing downwards) 
- RSI - register source index (source for data copies) 
- RDI - register destination index (destination for data copies)
- RIP - Instruction Pointer (pointer to the next instruction)
- Replace the “R” with an “E” and you get the analogous instruction in x86.


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Refresher: Types
:::

::: left
<!-- element style="font-size: 24px"-->
- Byte: 8 bits
- Word: 2 bytes (16 bits)
- Double Word (Dword) 32 bits
- Quadword: 64 bits
- Double Quadword: 128 bits
- Intel stores bytes as “Little Endian”


:::

::: right
![[0x05_slide_32_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Declaration Mapping
---
<!-- slide template="[[Title Slide]]" -->
 ## Common 
Instructions
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling Conventions

:::

<!-- element style="font-size: 24px"-->
- Calling conventions are 
conventions 
used to invoke functions. This includes how to pass arguments to the function, and how to get returned objects.
- Functions defined do not need to abide by this convention
	- In fact, weird calling conventions is a common obfuscation technique 
- The Windows API has a standardized calling convention for most of its functions. 
	- Note that WinAPI expands to 
__stdcall

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows x64 Calling Convention: Simple case

:::

<!-- element style="font-size: 24px"-->
- RCX, RDX, R8, R9 are used for integer, and pointer arguments in that order from left to right
- Additional arguments are pushed to the stack (left to right)
- The return value (integer/pointer) is stored in RAX if it is 64 bits or less 
- Return values > 64 bits (structs, classes) will have stack space allocated by the 
caller
	- This case is a bit more complicated and will be covered when we start reverse engineering C++ objects 
-  RAX, RCX, RDX, R8, R9, R10, and R11 are 
volatile
- Src: https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How are we learning x64 in this class?

:::

<!-- element style="font-size: 24px"-->
- The best way to get more comfortable reading assembly is to keep reading assembly. 
- You do not have to write (much) assembly in this course, but you will have to read it. 
- The decompiler offered by Ghidra will often make mistakes, and incorrectly reflect what the program is doing. 
- The disassembled  program is (usually) the ground truth

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Looking at Assembly:
:::

::: left
<!-- element style="font-size: 24px"-->
- We will use Intel Flavor assembly syntax. Why? Because it is better. 
- Why is it better? Because that happens to be the convention I learned.
- Examples:
- Basic MessageBox
- MessageBox Thread
- Crackme (Relevant to homework)
- Troll.exe 


:::

::: right
![[0x05_slide_38_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Ghidra
:::

::: left
<!-- element style="font-size: 24px"-->
- Free and open source reverse engineering framework
- Supports a TON of architectures (SLED is awesome!)
- Decompiler is very decent! Comparable to IDA pro

:::

::: right
![[0x05_slide_39_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Using Ghidra to Look at our code
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example: MessageBox

:::
```asm
 GLOBAL WhateverIWantToCallIt
    EXTERN ExitProcess
    EXTERN GetStdHandle
    EXTERN WriteFile 


    SECTION .text
WhateverIWantToCallIt:
    ; stack
    and rsp, -10h
    sub rsp, 020h

    mov rcx, -0Bh ; -11 is STD_OUTPUT_HANDLE
    call GetStdHandle; stores handle in RAX
    mov rcx, rax ; RCX is first ARG, put the handle in there
    mov rdx, message; put address of message in second argument
    mov r8, msglen 
    xor r9, r9 ; null
    push r9 ; put final argument on stack
    sub rsp, 20h;
    call WriteFile
    add rsp, 28h
    mov rcx, 0
    call ExitProcess
    xor rax, rax
    ret ; same as return 0

    SECTION .data
    message db "hello, world", 10
    msglen equ $-message
```
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack: what is it good for?

:::

<!-- element style="font-size: 24px"-->
- Local variables
- Passing arguments to a function
- Returning values from a  function 
- Function invocation/ABI

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Data structure built on top of our Virtual Address Space that allows us to Push, and pop values from a stack
- Whenever we invoke a function with 
call 
 a new 
stack frame
 is created. We call this the function call stack
- This is a contiguous chunk of memory that acts as a working space for a function’s duration

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Stack memory is temporary: once the function returns the memory is reclaimed
- Still error prone but is typically safer and faster than Heap allocations  
- A programer usually does not need to worry about managing stack memory
- We need to know how much is needed at compile time!


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Stack based Footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- Stack overflows
- Referencing reclaimed stack memory 
- careful when copying/referencing strings/raw data
- Note: You cannot return a string from a function safely! 

:::

::: right
![[0x05_slide_45_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Heap Memory
:::

::: left
<!-- element style="font-size: 24px"-->
- Memory that can be allocated/deallocated at runtime
- Used for data whose size is not known at compile time
- Slower than stack 


:::

::: right
![[0x05_slide_46_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Heap Allocation

:::

<!-- element style="font-size: 24px"-->
- Allows for dynamic allocation sizes. 
- Recall we don’t need to know how much memory is needed at compile time
- Heap memory is managed by a heap allocator. 
- The programmer allocates with a call to malloc and frees the memory with a call to free
- If the programmer forgets to call free, that memory is now unusable until the process terminates and we have introduced a memory leak


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### C/C++ In a nutshell 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x05_slide_48_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Footguns. So many footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- If you try and free memory that has already been freed, you are going to get undefined behavior and possibly an exploitable bug. 
- This is called a double free


:::

::: right
![[0x05_slide_49_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Footguns. So many footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- If you try and reference memory that has already been freed, you are going to get undefined behavior and possibly an exploitable bug. 
- This is called a use after free bug


:::

::: right
![[0x05_slide_50_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Dead Squirrels: AKA uninitialized memory 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x05_slide_51_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Uninitialized memory

:::

<!-- element style="font-size: 24px"-->
- An uninitialized variable is one that is declared, with no value set
- For example, DWORD x; char x[20];
- Depending on the compiler, the contents of x could be completely random 
- This will lead to unexpected behavior 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory Corruption

:::

<!-- element style="font-size: 24px"-->
- Allocating memory on the heap (malloc/new) without freeing it 
- This memory is no longer usable for allocation and from the perspective of the processes is used
- Some compilers/runtimes will detect when allocations have gone out of scope
- You should not rely on this. Anytime you call new/malloc, you should also call delete/free 
- 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Returning Stack Variables 

:::

<!-- element style="font-size: 24px"-->
- If we have a pointer to memory in a stack frame, when we exit the function that memory might no longer be valid
- By accessing it directly after the function it might look OK, but this is incredibly dangerous 
- In particular, the process will reclaim this memory and it will likely be filled with garbage. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### HW is up!
:::

::: left
<!-- element style="font-size: 20px"-->
- It is Due two weeks from today. You should get started on this ASAP. 
- In this assignment you will get exposed to CrackMes: puzzles used to practice your reverse engineering skills!
- The goal is simple: Find the input that makes the binary print “Cracked!”
- In this assignment you will get comfortable staring at some basic assembly, and finding the main function when a C-runtime is used.
- You don’t have to ever run the binary, but you can to verify your answer!


:::

::: right
![[0x05_slide_55_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Get started soon!
:::

::: left
<!-- element style="font-size: 24px"-->
- If you don’t have previous reverse engineering experience, you probably can’t do this homework the night before it is due!
- Get started ASAP: it is difficult to predict where you will get stuck!
- None of the CrackMes are designed to trick you per say, but they might not be straight forward!


:::

::: right
![[0x05_slide_56_image.png|200]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### CrackMes 2021: A Savage Hypocrisy 
:::

::: left
<!-- element style="font-size: 24px"-->
- Let’s look at the CrackMe’s I released for the first iteration of the class.
- We will only cover the first 3, but you are welcome to check out the binaries/solutions on the previous course github

:::

::: right
![[0x05_slide_57_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Analysis Playbook
:::




![[0x05_slide_58_image.png|500]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Finding the actual Main Function

:::

<!-- element style="font-size: 24px"-->
- Malware authors can make this very, very difficult
- In the simple case, where the only functions that come before the main function are startup code for the SEH, C runtime and possible security cookies.
	- Just look for the last function called in _entry that returns an int.
- Warning: TLS callbacks are executed before entry and can be used to hide the real entry point
- Finding main: X-refs are your friend!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Finding Main: Crackmes

:::

<!-- element style="font-size: 24px"-->
- Run the binary and see what the failure message is. X-ref and roll back
- Search for Strings and find the success message. X-ref and roll back
- int main(...) returns an int then calls exit. Find functions executed before calls to exit 
- Look for imports in the crackmes and x-ref

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 0
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended difficulty: trivial (so long as you know how to find the main entry point!)
- Run strings on the binary. 
- Find main
- See that it is directly comparing your input to a static string

:::

::: right
![[0x05_slide_61_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 1:
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Easy
- The binary checks if the length of the input is 26, and if it starts with a C

:::

::: right
![[0x05_slide_62_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (Learn from my mistakes. )
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Moderate
- Question to answer: WTF is happening inside of that do-while loop?

:::

::: right
![[0x05_slide_63_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Crackme 2 (Again, learn from my mistakes!)

:::

<!-- element style="font-size: 24px"-->
- A stack variable is declared, with values inside of the ASCII range (HINT)
- We iterate through values in argv[1]
- Copy that character into a buffer
- Copy the char from the stack var into a buffer
- Checks to see if the the input char + 5 is the same as the stack variable
- If not, Fail. If yes, continue
- Once we are done checking all the characters in the stack string with no errors, Success 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (...Oops)
:::

::: left
<!-- element style="font-size: 24px"-->
- Moral of the story: Don’t leave your work until the night before it is due.
- You will make careless mistakes, and if you’re like me and don’t have tenure it could be a bad look!
- Also…maybe don’t use aggressive Debug statements. 
- OR git commit messages:
https://www.youtube.com/watch?v=KjYBh7rq0-Y


:::

::: right
![[0x05_slide_65_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### General Advice	

:::

<!-- element style="font-size: 24px"-->
- Consult the flow chart. You can waste a LOT of time reverse engineering going down rabbit holes. You can solve each crackme here by consulting the flow chart. 
- Tools to solve this crackme:
- PE-bear, Ghidra, python, Resource Hacker, Google 


